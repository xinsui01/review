# 浏览器工作原理与实战

## 浏览器多进程架构

### 进程和线程

- 并行处理
  > 计算机中的并⾏处理就是同⼀时刻处理多个任务  
  > 使⽤并⾏处理能⼤⼤提升性能。
- 线程 VS 进程
  - 多线程可以并⾏处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。
  - ⼀个进程就是⼀个程序的运⾏实例
    > 启动⼀个程序的时候，操作系统会为该程序创建⼀块内存，⽤来存放代码、运⾏中的数据和⼀个执⾏任务的主线程，我们把这样的⼀个运⾏环境叫进程
  - 线程是依附于进程的，⽽进程中使⽤多线程并⾏处理能提升运算效率。
  - 进程和线程之间的关系
    - 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃
    - 线程之间共享进程中的数据
    - 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存
      > 当⼀个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
    - 进程之间的内容相互隔离
      > 进程隔离是为保护操作系统中进程互不⼲扰的技术，每⼀个进程只能访问⾃⼰占有的数据，也就避免出现进程 A 写⼊数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以⼀个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进⾏数据的通信，这时候，就需要使⽤⽤于进程间通信（IPC）的机制了。
- chrome 进程架构
  - 1 个浏览器（Browser）主进程
    > 主要负责界⾯显示、⽤户交互、⼦进程管理，同时提供存储等功能
  - 1 个 GPU 进程
    > 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
  - 1 个⽹络（NetWork）进程
    > 主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
  - 多个渲染进程
    > 核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤户可以与之交互的⽹⻚，`排版引擎 Blink` 和 `JavaScript 引擎 V8` 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。`出于安全考虑，渲染进程都是运⾏在沙箱模式下`。
  - 多个插件进程
    > 主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。
- 多进程架构问题
  - 更⾼的资源占⽤
    > 因为每个进程都会包含公共基础结构的副本（如 JavaScript 运⾏环境），这就意味着浏览器会消耗更多的内存资源。
  - 更复杂的体系架构
    > 浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
- SOA 架构（面向服务的架构 - `Services Oriented Architecture`）

  - Chrome 整体架构会朝向现代操作系统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（Service），每个服务（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过 IPC 来通信，从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬标。
  - Chrome“⾯向服务的架构”的进程模型图

    ![Chrome“⾯向服务的架构”的进程模型图](../imgs/Chrome“⾯向服务的架构”的进程模型图.png)

  - 弹性架构

    ![Chrome 还提供灵活的弹性架构](../imgs/Chrome弹性架构.png)

- `process-per-site-instance`

  > 将“同⼀站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有⼦域名和不同的端⼝，⽐如下⾯这三个：  
  > https://time.geekbang.org  
  > https://www.geekbang.org  
  > https://www.geekbang.org:8080  
  > Chrome 的默认策略是，每个标签对应⼀个渲染进程。但是如果从⼀个⻚⾯打开了新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点时，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程。官⽅把这个默认策略叫 process-per-site-instance。  
  > 所以，这种情况下，⼀个⻚⾯崩溃了，会导致同⼀站点的⻚⾯同时崩溃，因为他们使⽤了同⼀个渲染进程。

## 从输⼊ URL 到⻚⾯展示，这中间发⽣了什么

![从输⼊ URL 到⻚⾯展示完整流程示意图](../imgs/从输⼊URL到⻚⾯展示完整流程示意图.png)

- 导航流程

  > ⽤户发出 URL 请求到⻚⾯开始解析的这个过程，就叫做导航

  - ⾸先，浏览器进程接收到⽤户输⼊的 URL 请求，浏览器进程便将该 URL 转发给⽹络进程。
    > 当⽤户输⼊关键字并键⼊回⻋之后，这意味着当前⻚⾯即将要被替换成新的⻚⾯，不过在这个流程继续之前，浏览器还给了当前⻚⾯⼀次执⾏ beforeunload 事件的机会，`beforeunload 事件允许⻚⾯在退出之前执⾏⼀些数据清理操作`，还可以询问⽤户是否要离开当前⻚⾯，⽐如当前⻚⾯可能有未提交完成的表单等情况，因此⽤户可以通过 beforeunload 事件来取消导航，让浏览器不再执⾏任何后续⼯作
  - 然后，在⽹络进程中发起真正的 URL 请求。

    > 浏览器进程会通过进程间通信（IPC）把 URL 请求发送⾄⽹络进程

  - 接着⽹络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
  - 浏览器进程接收到⽹络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程，发送 CommitNavigation 时会携带响应头、等基本信息。

    - 准备渲染进程

      > 默认情况下，Chrome 会为每个⻚⾯分配⼀个渲染进程，也就是说，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。但是，也有⼀些例外，在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。

      > Chrome 的默认策略是，每个标签对应⼀个渲染进程。但如果**从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程**。官⽅把这个默认策略叫 process-per-site-instance。

      ![多个⻚⾯直接运⾏在同⼀个渲染进程中](../imgs/多个⻚⾯共享同⼀个渲染进程.png)

      > 渲染进程准备好之后，还不能⽴即进⼊⽂档解析状态，因为此时的⽂档数据还在⽹络进程中，并没有提交给渲染进程，所以下⼀步就进⼊了提交⽂档阶段。

    - 提交文档

      > 所谓提交⽂档，就是指浏览器进程将⽹络进程接收到的 HTML 数据提交给渲染进程

      - ⾸先当浏览器进程接收到⽹络进程的响应头数据之后，便向渲染进程发起“提交⽂档”的消息
      - 渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴传输数据的“管道”
      - 等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
      - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web ⻚⾯

        ![当浏览器进程确认提交之后更新内容](../imgs/导航完成状态.png)

  - 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的⽅式是直接和⽹络进程建⽴数据管道；
  - 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析⻚⾯数据了”。
  - 浏览器进程接收到渲染进程“提交⽂档”的消息之后，便开始移除之前旧的⽂档，然后更新浏览器进程中的⻚⾯状态。

  > 到这里，⼀个完整的导航流程就“⾛”完了，这之后就要进⼊渲染阶段了。

  > 多个⻚⾯公⽤⼀个渲染进程，也就意味着多个⻚⾯公⽤同⼀个主线程，所有⻚⾯的任务都是在同⼀个主线程上执⾏，这些任务包括渲染流程，JavaScript 执⾏，⽤户交互的事件的响应等等。但是如果⼀个标签⻚⾥⾯执⾏⼀个死循环，那么意味着该 JavaScript 代码会⼀直霸占主线程，这样就导致了其它的⻚⾯⽆法使⽤该主线程，从⽽让所有⻚⾯都失去响应！

  > ⻚⾯进程关闭后，浏览器进程会接收到关闭的消息，然后浏览器进程会通知⽹络进程主动断开该⻚⾯的所有 tcp 连接。

  > 接受到第⼀批 inde.html 的数据就会发送提交⽂档的消息

  > 边下载边解析的，接收到第⼀批数据，便开始做 DOM 解析了！

  > 等所有资源加载完毕 (js、css、image) 等算渲染进程接收完数据

- 渲染流程

  > ⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了
