# 浏览器工作原理与实战

## 浏览器多进程架构

### 进程和线程

- 并行处理
  > 计算机中的并⾏处理就是同⼀时刻处理多个任务  
  > 使⽤并⾏处理能⼤⼤提升性能。
- 线程 VS 进程
  - 多线程可以并⾏处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。
  - ⼀个进程就是⼀个程序的运⾏实例
    > 启动⼀个程序的时候，操作系统会为该程序创建⼀块内存，⽤来存放代码、运⾏中的数据和⼀个执⾏任务的主线程，我们把这样的⼀个运⾏环境叫进程
  - 线程是依附于进程的，⽽进程中使⽤多线程并⾏处理能提升运算效率。
  - 进程和线程之间的关系
    - 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃
    - 线程之间共享进程中的数据
    - 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存
      > 当⼀个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
    - 进程之间的内容相互隔离
      > 进程隔离是为保护操作系统中进程互不⼲扰的技术，每⼀个进程只能访问⾃⼰占有的数据，也就避免出现进程 A 写⼊数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以⼀个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进⾏数据的通信，这时候，就需要使⽤⽤于进程间通信（IPC）的机制了。
- chrome 进程架构
  - 1 个浏览器（Browser）主进程
    > 主要负责界⾯显示、⽤户交互、⼦进程管理，同时提供存储等功能
  - 1 个 GPU 进程
    > 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
  - 1 个⽹络（NetWork）进程
    > 主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
  - 多个渲染进程
    > 核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤户可以与之交互的⽹⻚，`排版引擎 Blink` 和 `JavaScript 引擎 V8` 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。`出于安全考虑，渲染进程都是运⾏在沙箱模式下`。
  - 多个插件进程
    > 主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。
- 多进程架构问题
  - 更⾼的资源占⽤
    > 因为每个进程都会包含公共基础结构的副本（如 JavaScript 运⾏环境），这就意味着浏览器会消耗更多的内存资源。
  - 更复杂的体系架构
    > 浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
- SOA 架构（面向服务的架构 - `Services Oriented Architecture`）

  - Chrome 整体架构会朝向现代操作系统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（Service），每个服务（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过 IPC 来通信，从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬标。
  - Chrome“⾯向服务的架构”的进程模型图

    ![Chrome“⾯向服务的架构”的进程模型图](../imgs/Chrome“⾯向服务的架构”的进程模型图.png)

  - 弹性架构

    ![Chrome 还提供灵活的弹性架构](../imgs/Chrome弹性架构.png)

- `process-per-site-instance`

  > 将“同⼀站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有⼦域名和不同的端⼝，⽐如下⾯这三个：  
  > https://time.geekbang.org  
  > https://www.geekbang.org  
  > https://www.geekbang.org:8080  
  > Chrome 的默认策略是，每个标签对应⼀个渲染进程。但是如果从⼀个⻚⾯打开了新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点时，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程。官⽅把这个默认策略叫 process-per-site-instance。  
  > 所以，这种情况下，⼀个⻚⾯崩溃了，会导致同⼀站点的⻚⾯同时崩溃，因为他们使⽤了同⼀个渲染进程。

## 从输⼊ URL 到⻚⾯展示，这中间发⽣了什么

![从输⼊ URL 到⻚⾯展示完整流程示意图](../imgs/从输⼊URL到⻚⾯展示完整流程示意图.png)

### 导航流程

> ⽤户发出 URL 请求到⻚⾯开始解析的这个过程，就叫做导航

- ⾸先，浏览器进程接收到⽤户输⼊的 URL 请求，浏览器进程便将该 URL 转发给⽹络进程。
  > 当⽤户输⼊关键字并键⼊回⻋之后，这意味着当前⻚⾯即将要被替换成新的⻚⾯，不过在这个流程继续之前，浏览器还给了当前⻚⾯⼀次执⾏ beforeunload 事件的机会，`beforeunload 事件允许⻚⾯在退出之前执⾏⼀些数据清理操作`，还可以询问⽤户是否要离开当前⻚⾯，⽐如当前⻚⾯可能有未提交完成的表单等情况，因此⽤户可以通过 beforeunload 事件来取消导航，让浏览器不再执⾏任何后续⼯作
- 然后，在⽹络进程中发起真正的 URL 请求。

  > 浏览器进程会通过进程间通信（IPC）把 URL 请求发送⾄⽹络进程

- 接着⽹络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
- 浏览器进程接收到⽹络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程，发送 CommitNavigation 时会携带响应头、等基本信息。

  - 准备渲染进程

    > 默认情况下，Chrome 会为每个⻚⾯分配⼀个渲染进程，也就是说，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。但是，也有⼀些例外，在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。

    > Chrome 的默认策略是，每个标签对应⼀个渲染进程。但如果**从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程**。官⽅把这个默认策略叫 process-per-site-instance。

    ![多个⻚⾯直接运⾏在同⼀个渲染进程中](../imgs/多个⻚⾯共享同⼀个渲染进程.png)

    > 渲染进程准备好之后，还不能⽴即进⼊⽂档解析状态，因为此时的⽂档数据还在⽹络进程中，并没有提交给渲染进程，所以下⼀步就进⼊了提交⽂档阶段。

  - 提交文档

    > 所谓提交⽂档，就是指浏览器进程将⽹络进程接收到的 HTML 数据提交给渲染进程

    - ⾸先当浏览器进程接收到⽹络进程的响应头数据之后，便向渲染进程发起“提交⽂档”的消息
    - 渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴传输数据的“管道”
    - 等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
    - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web ⻚⾯

      ![当浏览器进程确认提交之后更新内容](../imgs/导航完成状态.png)

- 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的⽅式是直接和⽹络进程建⽴数据管道；
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析⻚⾯数据了”。
- 浏览器进程接收到渲染进程“提交⽂档”的消息之后，便开始移除之前旧的⽂档，然后更新浏览器进程中的⻚⾯状态。

> 到这里，⼀个完整的导航流程就“⾛”完了，这之后就要进⼊渲染阶段了。

> 多个⻚⾯公⽤⼀个渲染进程，也就意味着多个⻚⾯公⽤同⼀个主线程，所有⻚⾯的任务都是在同⼀个主线程上执⾏，这些任务包括渲染流程，JavaScript 执⾏，⽤户交互的事件的响应等等。但是如果⼀个标签⻚⾥⾯执⾏⼀个死循环，那么意味着该 JavaScript 代码会⼀直霸占主线程，这样就导致了其它的⻚⾯⽆法使⽤该主线程，从⽽让所有⻚⾯都失去响应！

> ⻚⾯进程关闭后，浏览器进程会接收到关闭的消息，然后浏览器进程会通知⽹络进程主动断开该⻚⾯的所有 tcp 连接。

> 接受到第⼀批 inde.html 的数据就会发送提交⽂档的消息

> 边下载边解析的，接收到第⼀批数据，便开始做 DOM 解析了！

> 等所有资源加载完毕 (js、css、image) 等算渲染进程接收完数据

### 渲染流程

> ⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了

- 构建 DOM 树

  > 浏览器⽆法直接理解和使⽤ HTML，所以需要将 HTML 转换为浏览器能够理解的结构 —— DOM 树

- 样式计算（Recalculate Style）

  > 计算出 DOM 节点中每个元素的具体样式

  - 把 CSS 转换为浏览器能够理解的结构

    > 当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 —— `styleSheets`

    > 可在 Chrome 控制台中查看其结构，输入 document.styleSheets 即可看到

    ![document.styleSheets](../imgs/styleSheets.png)

    > styleSheets 只包含通过 link 引入的样式和 style 标记内的样式

  - 转换样式表中的属性值，使其标准化

    > CSS ⽂本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化

    ![标准化属性值](../imgs/标准化属性值.png)

  - 计算出 DOM 树中每个节点的具体样式

    - CSS 的继承规则： 每个 DOM 节点都包含有⽗节点的样式。
    - CSS 的层叠规则

- 布局阶段

  > 计算出 DOM 树中**可见元素**的几何位置

  - 创建布局树
    - 遍历 DOM 树中的所有可见节点， 并把这些节点加到布局树中
    - 不可见的节点会被忽略掉，如 head 标签下的全部内容，script 标签，再比如属性包含 `display: none`, 所以这些元素也没有被包进布局树
  - 布局计算
    > 执行布局操作的时候，会把布局运算结果重新写回布局树中，所以布局树即是输入内容，也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰的将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰的分离输入和输出，从而让新设计的布局算法更加简单。

- 分层

  > ⻚⾯中有很多复杂的效果，如⼀些复杂的 3D 变换、⻚⾯滚动，或者使⽤ z-index 做 z 轴排序等，为了更加⽅便地实现这些效果，渲染引擎还需要**为特定的节点⽣成专⽤的图层，并⽣成⼀棵对应的图层树（LayerTree）**。

  > 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面

  > 如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

  - 满足以下两点中任意一点的元素就有可能被提升为单独的一层
    - 拥有层叠上下文属性的元素会被提升为单独的一层
      - 明确定位属性的元素
      - 定义透明属性的元素
      - 使用 CSS 滤镜的元素
      - 使用 z-index 的元素
    - 需要剪裁（clip）的地方也会被创建图层
      - 容器不足以显示内部子元素而裁剪容器的部分用于显示，渲染引擎会为超出的子元素单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层

- 图层绘制

  - 渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表

    ![绘制列表](../imgs/绘制列表.png)

    > 可以打开“开发者工具”的“Layers”标签，选择 document 层，来实际体验下绘制列表

    ![⼀个图层的绘制列表](../imgs/⼀个图层的绘制列表.jpg)

    > 区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程

- 栅格化（raster）操作

  绘制列表只是⽤来记录绘制顺序和绘制指令的列表，⽽实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系

  ![渲染进程中的合成线程和主线程](../imgs/渲染进程中的合成线程和主线程.png)

  当图层的绘制列表准备好后，主线程会把该绘制列表提交（commit）给合成线程

  通常⼀个⻚⾯可能很⼤，但是⽤户只能看到其中的⼀部分，我们把⽤户可以看到的这个部分叫做视⼝（viewport）。

  在有些情况下，有的图层可以很⼤，⽐如有的⻚⾯你使⽤滚动条要滚动好久才能滚动到底部，但是通过视⼝，⽤户只能看到⻚⾯的很⼩⼀部分，所以在这种情况下，要绘制出所有图层内容的话，就会产⽣太⼤的开销，⽽且也没有必要。

  基于这个原因，合成线程会将图层划分为图块（tile），这些图块的⼤⼩通常是 256x256 或者 512x512。

  然后合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格化，是指将图块转换为位图。⽽图块是栅格化执⾏的最⼩单位。渲染进程维护了⼀个栅格化的线程池，所有的图块栅格化都是在线程池内执⾏的，运⾏⽅式如下图所示：

  ![GPU 栅格化](../imgs/GPU%20栅格化.png)

  通常，栅格化过程都会使⽤ GPU 来加速⽣成，使⽤ GPU ⽣成位图的过程叫快速栅格化，或者 GPU 栅格化，⽣成的位图被保存在 GPU 内存中。

  GPU 操作是运⾏在 GPU 进程中，如果栅格化操作使⽤了 GPU，那么最终⽣成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

- 合成和显示

  ⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

  浏览器进程⾥⾯有⼀个叫 viz 的组件，⽤来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其⻚⾯内容绘制到内存中，最后再将内存显示在屏幕上。

- 渲染流⽔线⼤总结

  ![完整的渲染流⽔线示意图](../imgs/完整的渲染流⽔线示意图.png)

- 重排、重绘、合成

  - 更新了元素的集合属性（重排）
    ![更新了元素的集合属性（重排）](../imgs/更新元素的⼏何属性.png)
  - 更新元素的绘制属性（重绘）
    ![更新元素的绘制属性（重绘）](../imgs/更新元素背景.png)
  - 更改一个既不要布局也不要绘制的属性（合成）
    ![更改一个既不要布局也不要绘制的属性（合成）](../imgs/避开重排和重绘.png)

## 变量提升

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码的开头的“行为”。变量被提升后，会给变量设置默认值 undefined

- JavaScript 代码的执⾏流程

  实际上变量和函数声明在代码⾥的位置是不会改变的，⽽且是在编译阶段被 JavaScript 引擎放⼊内存中。

  - 编译阶段

    - 变量提升
      ```js
      var myName = undefined;
      function showName() {
        console.log("showName 被执行");
      }
      ```
    - 执行代码
      ```js
      showName();
      console.log(myName);
      myName = "极客时间";
      ```

    ![JavaScript 执⾏流程细化图](../imgs/JavaScript%20执⾏流程细化图.png)

    经过编译后，会生成两部分内容：**执行上下文（Execution context）**和**可执行代码**

    执行上下文是执行一段代码的运行环境。

    JavaScript 引擎会把声明以外的代码编译为字节码。

  - 执行阶段

    按照顺序一行一行的执行

- 代码出现相同的变量或者函数怎么办

  ```js
  function showName() {
    console.log("showName A");
  }
  showName(); // showName B
  function showName() {
    console.log("showName B");
  }
  showName(); // showName B
  ```

  后者的声明会覆盖前者的声明。

  ```js
  var showName = "showName string";
  function showName() {
    console.log("showName has been called");
  }
  console.log(showName); // showName string
  showName(); // Uncaught TypeError: showName is not a function
  ```

  同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值，即：如果声明变量的同时初始化或赋值那么变量优先级高于函数。

  ```js
  showName(); // 1
  var showName = function () {
    console.log(2);
  };
  function showName() {
    console.log(1);
  }
  ```

### JS 变量声明及初始化

- [深入理解 JavaScript 系列（12）：变量对象（Variable Object）](https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)

  - 只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现。
  - 在 DOM 中，全局对象的 window 属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)

    ```js
      global = {
        Math: <...>,
        String: <...>
        ...
        ...
        window: global //引用自身
      };
    ```

  - 未传值的形参和 arguments 内的值不共享

    ```js
    function foo(x, y, z) {
      // 声明的函数参数数量arguments (x, y, z)
      alert(foo.length); // 3

      // 真正传进来的参数个数(only x, y)
      alert(arguments.length); // 2

      // 参数的callee是函数自身
      alert(arguments.callee === foo); // true

      // 参数共享

      alert(x === arguments[0]); // true
      alert(x); // 10

      arguments[0] = 20;
      alert(x); // 20

      x = 30;
      alert(arguments[0]); // 30

      // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的

      z = 40;
      alert(arguments[2]); // undefined

      arguments[2] = 50;
      alert(z); // 40
    }

    foo(10, 20);
    ```

  - 当进入执行上下文(代码执行之前)时，VO 里已经包含了下列属性(前面已经说了)：
    - 函数的所有形参(如果我们是在函数执行上下文中)
      - 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和 undefined 值组成的一种变量对象的属性也将被创建。
    - 所有函数声明(FunctionDeclaration, FD)
      - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。
    - 所有变量声明(var, VariableDeclaration)
      - 由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。
  - 变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个进入上下文阶段，变量声明不会干扰 VO 中已经存在的同名函数声明或形式参数声明

[Javascript 函数声明的优先级高于变量声明的优先级，但不会覆盖变量赋值](https://blog.csdn.net/wy818/article/details/49247675)

### 执行上下文

#### [前端基础进阶（二）：执行上下文详细图解](https://www.jianshu.com/p/a6d37c77e8db)

- JS 运行环境大概包括三种情况：
  - 全局环境： JavaScript 代码运行起来会首先进入该环境
  - 函数环境：当函数被调用执行时，会进入当前函数中执行代码
  - eval（不建议使用，可忽略）

因此在一个 JavaScript 程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript 引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。

- 全局上下文在浏览器窗口关闭后出栈。
- 函数中，遇到 return 能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。

#### [JavaScript 深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)

```js
var scope = "global scope";

function checkScope() {
  var scope = "local scope";

  function f() {
    return scope;
  }

  return f();
}

checkScope(); // local scope
```

```js
var scope = "global scope";
function checkScope() {
  var scope = "local scope";

  function f() {
    return scope;
  }

  return f;
}

checkScope()(); // local scope
```

#### [什么是作用域和执行上下文](https://segmentfault.com/a/1190000009522006)

## 调用栈

可以使用断点（debugger) 或者 console.trace() 来查看调用栈信息

调用栈大小有两个指标： 最大栈容量和最大调用深度。满足其中一个就会栈溢出。

- 栈溢出

  调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出

- 尾递归优化（TCO）

  ```js
  function runStack(n) {
    if (n === 0) return 100;
    return runStack(n - 2);
  }
  runStack(50000);
  ```

  各大浏览器（除了 safari）没有部署尾调用优化

  V8 引擎实际上已经实现了尾调用优化，但是默认是关闭该功能的

  - [尾递归的后续探究](https://imweb.io/topic/5a244260a192c3b460fce275)

## 块级作用域

正是由于 JavaScript 存在变量提升这种特性，从⽽导致了很多与直觉不符的代码，这也是 JavaScript 的⼀个重要设计缺陷。

由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。

- 作用域

  作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量和函数的可⻅性和⽣命周期。

  - 全局作用域
  - 函数作用域
  - 块级作用域

    ```js
    function foo() {
      var a = 1;
      let b = 2;
      {
        let b = 3;
        var c = 4;
        let d = 5;
        console.log(a);
        console.log(b);
      }
      console.log(b);
      console.log(c);
      console.log(d);
    }
    foo();
    ```

    - 编译并创建执行上下文
      ![刚执⾏时 foo 函数的执⾏上下⽂](../imgs/刚执⾏时%20foo%20函数的执⾏上下⽂.png)

      - 函数内部通过 var 声明的变量，在编译阶段全部被放到**变量环境**中
      - 通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中

      ![执⾏ foo 函数内部作⽤域块时的执⾏上下⽂](../imgs/执⾏%20foo%20函数内部作⽤域块时的执⾏上下⽂.png)

      在词法环境内部维护了一个小型栈结构，栈底是函数最外层的变量，进入一个块级作用域后，就会把该作用域快内部的变量压到栈顶；当作用域执行完成后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构

## 作用域链

在 JavaScript 执行过程中，其作用域链是由词法作用域决定的

- 词法作用域

  词法作⽤域就是指**作⽤域是由代码中函数声明的位置来决定的**，所以词法作⽤域是**静态的作⽤域**，通过它就能够预测代码在执⾏过程中如何查找标识符。

- 闭包

  本来函数外部是无权访问函数内部的函数或者变量，但是通过外部变量引用或者返回函数方式使得函数能够在外部调用，在调用时执行上下文创建和执行过程中保留了变量对象和作用域链使其不会被垃圾回收的过程就是闭包

[前端基础进阶（六）：在 chrome 开发者工具中观察函数调用栈、作用域链与闭包](https://www.jianshu.com/p/73122bb3d262)

## this

在对象内部的⽅法中使⽤对象内部的属性是⼀个⾮常普遍的需求。但是 JavaScript 的作⽤域机制并不⽀持这⼀点，基于这个需求，JavaScript ⼜搞出来另外⼀套 this 机制。

![执行上下文](../imgs/执行上下文.png)

- [彻底理解 js 中 this 的指向，不必硬背。](https://www.cnblogs.com/pssp/p/5216085.html)
- [彻底理解 JavaScript 中的 this](https://juejin.im/post/5c049e6de51d45471745eb98)

## 栈空间和堆空间

### 语言类型

- 在使⽤之前就需要确认其变量数据类型的称为静态语⾔。相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为动态语⾔。
- 偷偷转换的操作称为隐式类型转换。⽀持隐式类型转换的语⾔称为弱类型语⾔，不⽀持隐式类型转换的语⾔称为强类型语⾔。

![语⾔类型图](../imgs/语⾔类型图.png)

### 内存空间

- 代码空间： 存储可执⾏代码
- 栈空间
  - JavaScript 引擎需要⽤栈来维护程序执⾏期间上下⽂的状态，如果栈空间⼤了话，所有的数据都存放在栈空间⾥⾯，那么会影响到上下⽂切换的效率，进⽽⼜影响到整个程序的执⾏效率
  - ESP（记录当前执⾏状态的指针），指向当前的执行上下文。当当前的函数执行结束后，JavaScript 会将 ESP 下移（上下文出栈）。上⾯的执⾏上下⽂虽然保存在栈内存中，但是已经是⽆效内存了。⽐如当调⽤另外⼀个函数时，这块内容会被直接覆盖掉，⽤来存放另外⼀个函数的执⾏上下⽂。
- 堆空间
  - 分代垃圾回收

[前端基础进阶：详细图解 JavaScript 内存空间](https://juejin.im/entry/589c29a9b123db16a3c18adf)

在 JS 中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存(heap)。

- 基础数据类型，这些值都有固定的大小，往往都保存在栈内存中，由系统自动分配存储空间。可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。
- 引用数据类型，比如数组 Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。

## 编译器和解释器

### 语言分类

按语⾔的执⾏流程，可以把语⾔划分为编译型语⾔和解释型语⾔。

![编译器和解释器“翻译”代码](../imgs/编译器和解释器“翻译”代码.png)

- 编译型语⾔

  在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂件，这样每次运⾏程序时，都可以直接运⾏该⼆进制⽂件，⽽不需要再次重新编译了。⽐如 C/C++、GO 等都是编译型语⾔。

- 解释型语⾔

  在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏

### V8 执行 JavaScript 的过程

![V8 执⾏⼀段代码流程图](../imgs/V8%20执⾏⼀段代码流程图.png)

- ⽣成抽象语法树（AST）和执⾏上下⽂
  - 词法分析
    将一行行的源码拆解成一个个的 token
  - 语法分析
  - 有了 AST 之后生成该段代码的执行上下文
- 生成字节码

  > 字节码就是介于 AST 和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其转换为机器码后才能执⾏。

  解释器 Ignition 会根据 AST ⽣成字节码，并解释执⾏字节码。

  ⼀开始 V8 并没有字节码，⽽是直接将 AST 转换为机器码，由于执⾏机器码的效率是⾮常⾼效的，所以这种⽅式在发布后的⼀段时间内运⾏效果是⾮常好的。但是随着 Chrome 在⼿机上⼴泛普及，特别是运⾏在 512M 内存的⼿机上，内存占⽤问题也暴露出来了，因为 **V8 需要消耗⼤量的内存来存放转换后的机器码**。为了解决内存占⽤问题，V8 团队⼤幅重构了引擎架构，引⼊字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

  机器码所占⽤的空间远远超过了字节码，所以使⽤字节码可以减少系统的内存使⽤。

- 执行代码

  如果有⼀段第⼀次执⾏的字节码，解释器 Ignition 会逐条解释执⾏。到了这⾥，相信你已经发现了，解释器 Ignition 除了负责⽣成字节码之外，它还有另外⼀个作⽤，就是解释执⾏字节码。在 Ignition 执⾏字节码的过程中，如果发现有热点代码（HotSpot），⽐如⼀段代码被重复执⾏多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。

![即时编译（JIT）技术](../imgs/即时编译（JIT）技术.png)

> bytecode 会比源文件大得多，会增加 loading 时间，v8 团队认为没必要

> 热点代码编译为机器码后以哈希表的形式存在 v8 的堆内存中

## 消息队列和事件循环

### 消息队列

消息队列是一种数据结构，可以存放要执行的任务。符合队列先进先出的特点

### 事件循环

#### setTimeout

<!-- 存放 setTimeout 任务的队列其实是一个 hashmap 结构，等到执行这个结构的时候，会计算 hashmap 中的每个任务是否到期了，到期了就去执⾏，直到所有到期的任务都执⾏结束，才会进⼊下⼀轮循环 -->

定时器线程负责计时，到点了就把回调函数 push 到队列中

- 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
- 未激活的⻚⾯，setTimeout 执⾏最⼩间隔是 1000 毫秒（⽬的是为了优化后台⻚⾯的加载损耗以及降低耗电量）
- 延时执⾏时间有最⼤值

  Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最⼤只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值⼤于 2147483647 毫秒（⼤约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被⽴即执⾏。

  ```js
  function showName() {
    console.log("showName called");
  }
  var timeID = setTimeout(showName, 2147483648); //会被立即调⽤执⾏
  ```

## 渲染流水线下的 CSS

![含有 CSS 的⻚⾯渲染流⽔线](../imgs/含有CSS的页面渲染流水线.jpg)

⾸先是发起主⻚⾯的请求，这个发起请求⽅可能是渲染进程，也有可能是浏览器进程，发起的请求被送到⽹络进程中去执⾏。⽹络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这⾥你需要特别注意下，请求 HTML 数据和构建 DOM 中间有⼀段空闲时间，这个空闲时间有可能成为⻚⾯渲染的瓶颈。

当渲染进程接收 HTML ⽂件字节流时，会先开启⼀个**预解析线程**，如果遇到 JavaScript ⽂件或者 CSS ⽂件，那么预解析线程会提前下载这些数据。对于上⾯的代码，预解析线程会解析出来⼀个外部的 theme.css ⽂件，并发起 theme.css 的下载。这⾥也有⼀个空闲时间需要你注意⼀下，就是在 DOM 构建结束之后、theme.css ⽂件还未下载完成的这段时间内，渲染流⽔线⽆事可做，因为下⼀步是合成布局树，⽽合成布局树需要 CSSOM 和 DOM，所以这⾥需要等待 CSS 加载结束并解析成 CSSOM。

和 DOM ⼀样，CSSOM 也具有两个作⽤，第⼀个是**提供给 JavaScript 操作样式表的能⼒**，第⼆个是**为布局树的合成提供基础的样式信息**。这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

在执⾏ JavaScript 脚本之前，如果⻚⾯中包含了外部 CSS ⽂件的引⽤，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能⼒，所以在执⾏ JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的⽣成。

```css
// theme.css
div {
  color: green;
  background-color: black;
}
```

```js
// foo.js
console.log('script)
```

```html
<html>
  <head>
    <link href="theme.css" rel="stylesheet" />
  </head>
  <body>
    <div>geekbang com</div>
    <script src="foo.js"></script>
    <div>geekbang com</div>
  </body>
</html>
```

![含有 JavaScript ⽂件和 CSS ⽂件⻚⾯的渲染流⽔线](../imgs/含有%20JavaScript%20⽂件和%20CSS%20⽂件⻚⾯的渲染流⽔线.png)

在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS ⽂件和 JavaScript ⽂件需要下载，然后就同时发起这两个⽂件的下载请求，需要注意的是，这两个⽂件的下载过程是重叠的，所以下载时间按照最久的那个⽂件来算。

### 缩短白屏时间

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的⽂件下载，这样获取到 HTML ⽂件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少⽂件⼤⼩，⽐如通过 webpack 等⼯具移除⼀些不必要的注释，并压缩 JavaScript ⽂件。
- 将⼀些不需要在解析 HTML 阶段使⽤的 JavaScript 标记上 sync 或者 defer。
- 对于⼤的 CSS ⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的 CSS ⽂件，这样只有在特定的场景下才会加载特定的 CSS ⽂件。

## 分层和合成机制：为什么 CSS 动画⽐ JavaScript ⾼效

- 显示器是怎么显示图像的

  每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图⽚，更新的图⽚都来⾃于显卡中⼀个叫**前缓冲区**的地⽅，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。

- 显卡做什么

  显卡的职责就是合成新的图像，并将图像保存到**后缓冲区**中，⼀旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是⼀致的。但有时候，在⼀些复杂的场景中，显卡处理⼀张图⽚的速度会变慢，这样就会造成视觉上的卡顿。

- 帧 VS 帧率

  通过滚动条滚动⻚⾯，或者通过⼿势缩放⻚⾯时，屏幕上就会产⽣动画的效果。之所以能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流⽔线⽣成新的图⽚，并发送到显卡的后缓冲区。

  我们把渲染流⽔线⽣成的每⼀副图⽚称为⼀帧，把渲染流⽔线每秒更新了多少帧称为帧率。

### Chrome 中的合成技术，可以⽤三个词来概括总结：分层、分块和合成

- 分层和合成

  一些复杂的动效，如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这中绘制策略会严重影响页面的渲染效率。

  为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。

  需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线程执⾏的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执⾏的原因。

- 分块

  如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层⾯提升了渲染效率。

  合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块，这样
  就可以⼤⼤加速⻚⾯的显示速度。即使只绘制那些优先级最⾼的图块，也要耗费不少的时间，因为涉及到⼀个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会⽐较慢。

  为了解决这个问题，Chrome ⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚。⽐如可以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。在⾸次显示⻚⾯内容的时候，将这个低分辨率的图⽚显示出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显示的低分辨率内容。这种⽅式尽管会让⽤户在开始时看到的是低分辨率的内容，但是也⽐⽤户在开始时什么都看不到要好。

### 利⽤分层技术优化代码

```css
.box {
  will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做⼏何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现⼀层，等这些变换发⽣时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就⼤⼤提升了渲染的效率。这也是 CSS 动画⽐ JavaScript 动画⾼效的原因。

每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存，所以你需要恰当地使⽤ will-change。

## 优化⻚⾯性能

### 加载阶段

减少关键资源个数， 降低关键资源⼤⼩，降低关键资源的 RTT（Round Trip Time）次数。

- RTT：表示从发送端发送数据开始，到发送端收到来⾃接收端的确认，总共经历的时延

### 交互阶段

- 减少 JavaScript 脚本执⾏时间
  - 将⼀次执⾏的函数分解为多个任务，使得每次的执⾏时间不要过久。
  - 采⽤ Web Workers。你可以把 Web Workers 当作主线程之外的⼀个线程，在
    Web Workers 中是可以执⾏ JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是⽆法通过 JavaScript 来访问 DOM 的，所以我们可以把⼀些和 DOM 操作⽆关且耗时的任务放到 Web Workers 中去执⾏。
- 避免强制同步布局

  main_div.offsetHeight， 如果要获取到 main_div 的⾼度，就需要重新布局

- 避免布局抖动

  所谓布局抖动，是指在⼀次 JavaScript 执⾏过程中，多次执⾏强制布局和抖动操作。

  ```js
  function foo() {
    let time_li = document.getElementById("time_li");
    for (let i = 0; i < 100; i++) {
      let main_div = document.getElementById("mian_div");
      let new_node = document.createElement("li");
      let textnode = document.createTextNode("time.geekbang");
      new_node.appendChild(textnode);
      new_node.offsetHeight = time_li.offsetHeight;
      document.getElementById("mian_div").appendChild(new_node);
    }
  }
  ```

  我们在⼀个 for 循环语句⾥⾯不断读取属性值，每次读取属性值之前都要进⾏计算样式和布局。

- 合理利⽤ CSS 合成动画

## vDOM

### 双缓存

使⽤双缓存，可以让你先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显示缓冲区，这样就使得整个图像的输出⾮常稳定。

虚拟 DOM 看成是 DOM 的⼀个 buffer，和图形显示⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到 DOM 上，这样就能减少⼀些不必要的更新，同时还能保证 DOM 的稳定输出。

### 基于 React 和 Redux 构建 MVC 模型

![基于 React 和 Redux 构建 MVC 模型](../imgs/基于%20React%20和%20Redux%20构建%20MVC%20模型.png)

## PWA

通过引⼊ Service Worker 来试着解决离线存储和消息推送的问题，通过引⼊ manifest.json 来解决⼀级⼊⼝的问题

- Service Worker
  在⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求。

  Web Worker 的⽬的是让 JavaScript 能够运⾏在⻚⾯主线程之外，不过由于 Web Worker 中是没有当前⻚⾯的 DOM 环境的，所以在 Web Worker 中只能执⾏⼀些和 DOM ⽆关的 JavaScript 脚本，并通过 postMessage ⽅法将执⾏的结果返回给主线程.

  在 Chrome 中， Web Worker 其实就是在渲染进程中开启的⼀个新线程，它的⽣命周期是和⻚⾯关联的。

  “让其运⾏在主线程之外”就是 Service Worker 来⾃ Web Worker 的⼀个核⼼思想。

  Web Worker 是临时的，每次 JavaScript 脚本执⾏完成之后都会退出，执⾏结果也不能保存下来，如果下次还有同样的操作，就还得重新来⼀遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。

  由于 Service Worker 还需要会为多个⻚⾯提供服务，所以还不能把 Service
  Worker 和单个⻚⾯绑定起来

  要使站点⽀持 Service Worker，⾸先必要的⼀步就是要将站点升级到 HTTPS。除了必须要使⽤ HTTPS，Service Worker 还需要同时⽀持 Web ⻚⾯默认的安全策略、同源策略、内容安全策略（CSP）等

## WebComponent

- 阻碍前端组件化的因素
  - CSS 是影响全局的
  - ⻚⾯中只有⼀个 DOM，任何地⽅都可以直接读取和修改 DOM
- WebComponent 给出了解决思路，它提供了对局部视图封装能⼒，可以让 DOM、
  CSSOM 和 JavaScript 运⾏在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。
- WebComponent 是⼀套技术的组合，具体涉及到了 Custom elements（⾃定义元素）、Shadow DOM（影⼦ DOM）和 HTML templates（HTML 模板）

```html
<!DOCTYPE html>
<html>
  <body>
    <!--
⼀：定义模板
⼆：定义内部CSS样式
三：定义JavaScript⾏为
-->
    <template id="geekbang-t">
      <style>
        p {
          background-color: brown;
          color: cornsilk;
        }
        div {
          width: 200px;
          background-color: bisque;
          border: 3px solid chocolate;
          border-radius: 10px;
        }
      </style>
      <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
      </div>
      <script>
        function foo() {
          console.log("inner log");
        }
      </script>
    </template>
    <script>
      class GeekBang extends HTMLElement {
        constructor() {
          super();
          //获取组件模板
          const content = document.querySelector("#geekbang-t").content;
          //创建影⼦DOM节点
          const shadowDOM = this.attachShadow({ mode: "open" });
          //将模板添加到影⼦DOM上
          shadowDOM.appendChild(content.cloneNode(true));
        }
      }
      customElements.define("geek-bang", GeekBang);
    </script>
    <geek-bang></geek-bang>
    <div>
      <p>time.geekbang.org</p>
      <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
  </body>
</html>
```

- ShadowDOM 的作⽤是将模板中的内容与全局 DOM 和 CSS 进⾏隔离，这样我们就可以实现元素和样式的私有化了
