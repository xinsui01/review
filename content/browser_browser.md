# 浏览器工作原理与实战

## 浏览器多进程架构

### 进程和线程

- 并行处理
  > 计算机中的并⾏处理就是同⼀时刻处理多个任务  
  > 使⽤并⾏处理能⼤⼤提升性能。
- 线程 VS 进程
  - 多线程可以并⾏处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。
  - ⼀个进程就是⼀个程序的运⾏实例
    > 启动⼀个程序的时候，操作系统会为该程序创建⼀块内存，⽤来存放代码、运⾏中的数据和⼀个执⾏任务的主线程，我们把这样的⼀个运⾏环境叫进程
  - 线程是依附于进程的，⽽进程中使⽤多线程并⾏处理能提升运算效率。
  - 进程和线程之间的关系
    - 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃
    - 线程之间共享进程中的数据
    - 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存
      > 当⼀个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
    - 进程之间的内容相互隔离
      > 进程隔离是为保护操作系统中进程互不⼲扰的技术，每⼀个进程只能访问⾃⼰占有的数据，也就避免出现进程 A 写⼊数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以⼀个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进⾏数据的通信，这时候，就需要使⽤⽤于进程间通信（IPC）的机制了。
- chrome 进程架构
  - 1 个浏览器（Browser）主进程
    > 主要负责界⾯显示、⽤户交互、⼦进程管理，同时提供存储等功能
  - 1 个 GPU 进程
    > 其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
  - 1 个⽹络（NetWork）进程
    > 主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
  - 多个渲染进程
    > 核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤户可以与之交互的⽹⻚，`排版引擎 Blink` 和 `JavaScript 引擎 V8` 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。`出于安全考虑，渲染进程都是运⾏在沙箱模式下`。
  - 多个插件进程
    > 主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。
- 多进程架构问题
  - 更⾼的资源占⽤
    > 因为每个进程都会包含公共基础结构的副本（如 JavaScript 运⾏环境），这就意味着浏览器会消耗更多的内存资源。
  - 更复杂的体系架构
    > 浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
- SOA 架构（面向服务的架构 - `Services Oriented Architecture`）

  - Chrome 整体架构会朝向现代操作系统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（Service），每个服务（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过 IPC 来通信，从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬标。
  - Chrome“⾯向服务的架构”的进程模型图

    ![Chrome“⾯向服务的架构”的进程模型图](../imgs/Chrome“⾯向服务的架构”的进程模型图.png)

  - 弹性架构

    ![Chrome 还提供灵活的弹性架构](../imgs/Chrome弹性架构.png)

- `process-per-site-instance`

  > 将“同⼀站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有⼦域名和不同的端⼝，⽐如下⾯这三个：  
  > https://time.geekbang.org  
  > https://www.geekbang.org  
  > https://www.geekbang.org:8080  
  > Chrome 的默认策略是，每个标签对应⼀个渲染进程。但是如果从⼀个⻚⾯打开了新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点时，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程。官⽅把这个默认策略叫 process-per-site-instance。  
  > 所以，这种情况下，⼀个⻚⾯崩溃了，会导致同⼀站点的⻚⾯同时崩溃，因为他们使⽤了同⼀个渲染进程。
