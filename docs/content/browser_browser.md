# 浏览器工作原理与实战

## 浏览器多进程架构

### 进程和线程

- 并行处理
  计算机中的并⾏处理就是同⼀时刻处理多个任务  
  使⽤并⾏处理能⼤⼤提升性能。
- 线程 VS 进程
  - ⼀个进程就是⼀个程序的运⾏实例
    启动⼀个程序的时候，操作系统会为该程序创建⼀块内存，⽤来存放代码、运⾏中的数据和⼀个执⾏任务的主线程，我们把这样的⼀个运⾏环境叫进程
  - 进程是 os 独立分配资源的单位，而线程只是共享进程的资源.
  - 线程是依附于进程的，⽽进程中使⽤多线程并⾏处理能提升运算效率。
  - 线程只是作为独立调度执行的基本单元
  - 多线程可以并⾏处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。
  - 进程和线程之间的关系
    - 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃
    - 线程之间共享进程中的数据
    - 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存
      当⼀个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
    - 进程之间的内容相互隔离
      进程隔离是为保护操作系统中进程互不⼲扰的技术，每⼀个进程只能访问⾃⼰占有的数据，也就避免出现进程 A 写⼊数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以⼀个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进⾏数据的通信，这时候，就需要使⽤⽤于进程间通信（IPC）的机制了。
- chrome 进程架构
  - 1 个浏览器（Browser）主进程
    主要负责界⾯显示、⽤户交互、⼦进程管理，同时提供存储等功能
  - 1 个 GPU 进程
    其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
  - 1 个⽹络（NetWork）进程
    主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
  - 多个渲染进程
    核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤户可以与之交互的⽹⻚，`排版引擎 Blink` 和 `JavaScript 引擎 V8` 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。`出于安全考虑，渲染进程都是运⾏在沙箱模式下`。
  - 多个插件进程
    主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。
- 多进程架构问题
  - 更⾼的资源占⽤
    因为每个进程都会包含公共基础结构的副本（如 JavaScript 运⾏环境），这就意味着浏览器会消耗更多的内存资源。
  - 更复杂的体系架构
    浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
- SOA 架构（面向服务的架构 - `Services Oriented Architecture`）

  - Chrome 整体架构会朝向现代操作系统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（Service），每个服务（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过 IPC 来通信，从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬标。
  - Chrome“⾯向服务的架构”的进程模型图

    ![Chrome“⾯向服务的架构”的进程模型图](../imgs/browser/Chrome“⾯向服务的架构”的进程模型图.png)

  - 弹性架构

    ![Chrome 还提供灵活的弹性架构](../imgs/browser/Chrome弹性架构.png)

- `process-per-site-instance`

  将“同⼀站点”定义为**根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://）**，还包含了该根域名下的所有⼦域名和不同的端⼝，⽐如下⾯这三个：  
  `https://time.geekbang.org`
  `https://www.geekbang.org`
  `https://www.geekbang.org:8080`
  Chrome 的默认策略是，每个标签对应⼀个渲染进程。但是如果从⼀个⻚⾯打开了新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点时，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程。官⽅把这个默认策略叫 process-per-site-instance。  
  所以，这种情况下，⼀个⻚⾯崩溃了，会导致同⼀站点的⻚⾯同时崩溃，因为他们使⽤了同⼀个渲染进程。

- 标签⻚之间的连接

  ```html
  <a href="https://www.abc.com" target="_blank">首页</a>
  ```

  点击该链接会打开新的标签页，新标签页中的 window.opener 的值就是指向上一个标签页中的 window，这样就可以在新的标签页中通过 opener 来操作上个标签页了。这样，我们说这两个标签页是有连接的

  还可以通过 JavaScript 中的 window.open 方法来和新标签页建立连接

  ```js
  const new_window = window.open("https://www.abc.com");
  ```

  通过上面的操作，可以在当前标签页中通过 new_window 来控制新标签页，还可以在新标签页中通过 window.opener 来控制当前标签页。

  把这类具有相互连接关系的标签页称为浏览上下文组（browsing context group）.

  把一个标签页所包含的内容，诸如 window 对象、历史记录、滚动条位置等信息称为浏览器上下文。这些通通过脚本互相连接起来的浏览器上下文就是浏览上下文组

  Chrome 会将浏览上下文组中属于同一个站点的标签分配到同一个渲染进程中。这是因为如果一组标签页，既在同一个浏览上下文中，又属于同一站点，那么他们可能需要在对方的标签页中执行脚本。因此，他们必须运行在同一个渲染进程中。

  ```html
  <a target="_blank" rel="noopener noreferrer"></a>
  ```

  将 noopener 的值引⼊ rel 属性中，就是告诉浏览器通过这个链接打开的标签⻚中的 opener 值设置为 null，引⼊ noreferrer 是告诉浏览器，新打开的标签⻚不要有引⽤关系。当然它们也就不属于同⼀浏览上下⽂组了.

- 站点隔离

  ⽬前 Chrome 浏览器已经默认实现了站点隔离的功能，这意味着标签⻚中的 iframe 也会遵守同⼀站点的分配原则，如果标签⻚中的 iframe 和标签⻚是同⼀站点，并且有连接关系，那么标签⻚依然会和当前标签⻚运⾏在同⼀个渲染进程中，如果 iframe 和标签⻚不属于同⼀站点，那么 iframe 会运⾏在单独的渲染进程中。

  ```html
  <html>
    <head>
      <title>站点隔离:demo</title>
      <style>
        iframe {
          width: 800px;
          height: 300px;
        }
      </style>
    </head>
    <body>
      <div><iframe src="iframe.html"></iframe></div>
      <div><iframe src="https://www.infoq.cn/"></iframe></div>
      <div><iframe src="https://time.geekbang.org/"></iframe></div>
      <div><iframe src="https://www.geekbang.org/"></iframe></div>
    </body>
  </html>
  ```

  ![iframe 使⽤单独的渲染进程](../imgs/browser/iframe%20使⽤单独的渲染进程.png)

  我们可以发现，由于 InfoQ、极客邦两个 iframe 与⽗标签⻚不属于同⼀站点，所以它们会被分配到不同的渲染进程中，⽽ iframe.html 和源标签⻚属于同⼀站点，所以它会和源标签⻚运⾏在同⼀个渲染进程中。

## 从输⼊ URL 到⻚⾯展示，这中间发⽣了什么

![从输⼊ URL 到⻚⾯展示完整流程示意图](../imgs/browser/从输⼊URL到⻚⾯展示完整流程示意图.png)

### 导航流程

> ⽤户发出 URL 请求到⻚⾯开始解析的这个过程，就叫做导航

- ⾸先，浏览器进程接收到⽤户输⼊的 URL 请求，浏览器进程便将该 URL 转发给⽹络进程。
  当⽤户输⼊关键字并键⼊回⻋之后，这意味着当前⻚⾯即将要被替换成新的⻚⾯，不过在这个流程继续之前，浏览器还给了当前⻚⾯⼀次执⾏ beforeunload 事件的机会，`beforeunload 事件允许⻚⾯在退出之前执⾏⼀些数据清理操作`，还可以询问⽤户是否要离开当前⻚⾯，⽐如当前⻚⾯可能有未提交完成的表单等情况，因此⽤户可以通过 beforeunload 事件来取消导航，让浏览器不再执⾏任何后续⼯作
- 然后，在⽹络进程中发起真正的 URL 请求。

  浏览器进程会通过进程间通信（IPC）把 URL 请求发送⾄⽹络进程

- 接着⽹络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
- 浏览器进程接收到⽹络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程，发送 CommitNavigation 时会携带响应头、等基本信息。

  - 准备渲染进程

    默认情况下，Chrome 会为每个⻚⾯分配⼀个渲染进程，也就是说，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。但是，也有⼀些例外，在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。

    Chrome 的默认策略是，每个标签对应⼀个渲染进程。但如果**从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程**。官⽅把这个默认策略叫 process-per-site-instance。

    ![多个⻚⾯直接运⾏在同⼀个渲染进程中](../imgs/browser/多个⻚⾯共享同⼀个渲染进程.png)

    渲染进程准备好之后，还不能⽴即进⼊⽂档解析状态，因为此时的⽂档数据还在⽹络进程中，并没有提交给渲染进程，所以下⼀步就进⼊了提交⽂档阶段。

- 提交文档

  > 所谓提交⽂档，就是指浏览器进程将⽹络进程接收到的 HTML 数据提交给渲染进程

  - ⾸先当浏览器进程接收到⽹络进程的响应头数据之后，便向渲染进程发起“提交⽂档”的消息
  - 渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴传输数据的“管道”
  - 等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
  - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web ⻚⾯

    ![当浏览器进程确认提交之后更新内容](../imgs/browser/导航完成状态.png)

- 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的⽅式是直接和⽹络进程建⽴数据管道；

- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析⻚⾯数据了”。

- 浏览器进程接收到渲染进程“提交⽂档”的消息之后，便开始移除之前旧的⽂档，然后更新浏览器进程中的⻚⾯状态。

到这里，⼀个完整的导航流程就“⾛”完了，这之后就要进⼊渲染阶段了。

多个⻚⾯公⽤⼀个渲染进程，也就意味着多个⻚⾯公⽤同⼀个主线程，所有⻚⾯的任务都是在同⼀个主线程上执⾏，这些任务包括渲染流程，JavaScript 执⾏，⽤户交互的事件的响应等等。但是如果⼀个标签⻚⾥⾯执⾏⼀个死循环，那么意味着该 JavaScript 代码会⼀直霸占主线程，这样就导致了其它的⻚⾯⽆法使⽤该主线程，从⽽让所有⻚⾯都失去响应！

⻚⾯进程关闭后，浏览器进程会接收到关闭的消息，然后浏览器进程会通知⽹络进程主动断开该⻚⾯的所有 tcp 连接。

接受到第⼀批 inde.html 的数据就会发送提交⽂档的消息

边下载边解析的，接收到第⼀批数据，便开始做 DOM 解析了！

等所有资源加载完毕 (js、css、image) 等算渲染进程接收完数据

### 渲染流程

> ⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了

- 构建 DOM 树

  浏览器⽆法直接理解和使⽤ HTML，所以需要将 HTML 转换为浏览器能够理解的结构 —— DOM 树

- 样式计算（Recalculate Style）

  计算出 DOM 节点中每个元素的具体样式

  - 把 CSS 转换为浏览器能够理解的结构

    当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 —— `styleSheets`

    可在 Chrome 控制台中查看其结构，输入 document.styleSheets 即可看到

    ![document.styleSheets](../imgs/browser/styleSheets.png)

    styleSheets 只包含通过 link 引入的样式和 style 标记内的样式

  - 转换样式表中的属性值，使其标准化

    CSS ⽂本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化

    ![标准化属性值](../imgs/browser/标准化属性值.png)

  - 计算出 DOM 树中每个节点的具体样式

    - CSS 的继承规则： 每个 DOM 节点都包含有⽗节点的样式。
    - CSS 的层叠规则

- 布局阶段

  > 计算出 DOM 树中**可见元素**的几何位置

  - 创建布局树
    - 遍历 DOM 树中的所有可见节点， 并把这些节点加到布局树中
    - 不可见的节点会被忽略掉，如 head 标签下的全部内容，script 标签，再比如属性包含 `display: none`, 所以这些元素也没有被包进布局树
  - 布局计算
    执行布局操作的时候，会把布局运算结果重新写回布局树中，所以布局树即是输入内容，也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰的将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰的分离输入和输出，从而让新设计的布局算法更加简单。

- 分层

  ⻚⾯中有很多复杂的效果，如⼀些复杂的 3D 变换、⻚⾯滚动，或者使⽤ z-index 做 z 轴排序等，为了更加⽅便地实现这些效果，渲染引擎还需要**为特定的节点⽣成专⽤的图层，并⽣成⼀棵对应的图层树（LayerTree）**。

  浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面

  如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

  - 满足以下两点中任意一点的元素就有可能被提升为单独的一层
    - 拥有层叠上下文属性的元素会被提升为单独的一层
      - 明确定位属性的元素
      - 定义透明属性的元素
      - 使用 CSS 滤镜的元素
      - 使用 z-index 的元素
    - 需要剪裁（clip）的地方也会被创建图层
      - 容器不足以显示内部子元素而裁剪容器的部分用于显示，渲染引擎会为超出的子元素单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层

- 图层绘制

  - 渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表

    ![绘制列表](../imgs/browser/绘制列表.png)

    > 可以打开“开发者工具”的“Layers”标签，选择 document 层，来实际体验下绘制列表

    ![⼀个图层的绘制列表](../imgs/browser/⼀个图层的绘制列表.jpg)

    > 区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程

- 栅格化（raster）操作

  绘制列表只是⽤来记录绘制顺序和绘制指令的列表，⽽实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系

  ![渲染进程中的合成线程和主线程](../imgs/browser/渲染进程中的合成线程和主线程.png)

  当图层的绘制列表准备好后，主线程会把该绘制列表提交（commit）给合成线程

  通常⼀个⻚⾯可能很⼤，但是⽤户只能看到其中的⼀部分，我们把⽤户可以看到的这个部分叫做视⼝（viewport）。

  在有些情况下，有的图层可以很⼤，⽐如有的⻚⾯你使⽤滚动条要滚动好久才能滚动到底部，但是通过视⼝，⽤户只能看到⻚⾯的很⼩⼀部分，所以在这种情况下，要绘制出所有图层内容的话，就会产⽣太⼤的开销，⽽且也没有必要。

  基于这个原因，合成线程会将图层划分为图块（tile），这些图块的⼤⼩通常是 256x256 或者 512x512。

  然后合成线程会按照视⼝附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。所谓栅格化，是指将图块转换为位图。⽽图块是栅格化执⾏的最⼩单位。渲染进程维护了⼀个栅格化的线程池，所有的图块栅格化都是在线程池内执⾏的，运⾏⽅式如下图所示：

  ![GPU 栅格化](../imgs/browser/GPU%20栅格化.png)

  通常，栅格化过程都会使⽤ GPU 来加速⽣成，使⽤ GPU ⽣成位图的过程叫快速栅格化，或者 GPU 栅格化，⽣成的位图被保存在 GPU 内存中。

  GPU 操作是运⾏在 GPU 进程中，如果栅格化操作使⽤了 GPU，那么最终⽣成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

- 合成和显示

  ⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

  浏览器进程⾥⾯有⼀个叫 viz 的组件，⽤来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其⻚⾯内容绘制到内存中，最后再将内存显示在屏幕上。

- 渲染流⽔线⼤总结

  ![完整的渲染流⽔线示意图](../imgs/browser/完整的渲染流⽔线示意图.png)

- 重排、重绘、合成

  - 更新了元素的集合属性（重排）
    ![更新了元素的集合属性（重排）](../imgs/browser/更新元素的⼏何属性.png)
  - 更新元素的绘制属性（重绘）
    ![更新元素的绘制属性（重绘）](../imgs/browser/更新元素背景.png)
  - 更改一个既不要布局也不要绘制的属性（合成）
    ![更改一个既不要布局也不要绘制的属性（合成）](../imgs/browser/避开重排和重绘.png)

## 变量提升

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码的开头的“行为”。变量被提升后，会给变量设置默认值 undefined

- JavaScript 代码的执⾏流程

  实际上变量和函数声明在代码⾥的位置是不会改变的，⽽且是在编译阶段被 JavaScript 引擎放⼊内存中。

  - 编译阶段

    - 变量提升
      ```js
      var myName = undefined;
      function showName() {
        console.log("showName 被执行");
      }
      ```
    - 执行代码
      ```js
      showName();
      console.log(myName);
      myName = "极客时间";
      ```

    ![JavaScript 执⾏流程细化图](../imgs/browser/JavaScript%20执⾏流程细化图.png)

    经过编译后，会生成两部分内容：**执行上下文（Execution context）**和**可执行代码**

    执行上下文是执行一段代码的运行环境。

    JavaScript 引擎会把声明以外的代码编译为字节码。

  - 执行阶段

    按照顺序一行一行的执行

- 代码出现相同的变量或者函数怎么办

  ```js
  function showName() {
    console.log("showName A");
  }
  showName(); // showName B
  function showName() {
    console.log("showName B");
  }
  showName(); // showName B
  ```

  后者的声明会覆盖前者的声明。

  ```js
  var showName = "showName string";
  function showName() {
    console.log("showName has been called");
  }
  console.log(showName); // showName string
  showName(); // Uncaught TypeError: showName is not a function
  ```

  同一个标识符的情况下，变量声明与函数声明都会提升；函数声明会覆盖变量声明，但不会覆盖变量赋值，即：如果声明变量的同时初始化或赋值那么变量优先级高于函数。

  ```js
  showName(); // 1
  var showName = function () {
    console.log(2);
  };
  function showName() {
    console.log(1);
  }
  ```

### JS 变量声明及初始化

- [深入理解 JavaScript 系列（12）：变量对象（Variable Object）](https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)

  - 只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现。
  - 在 DOM 中，全局对象的 window 属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)

    ```js
      global = {
        Math: <...>,
        String: <...>
        ...
        ...
        window: global //引用自身
      };
    ```

  - 未传值的形参和 arguments 内的值不共享

    ```js
    function foo(x, y, z) {
      // 声明的函数参数数量arguments (x, y, z)
      alert(foo.length); // 3

      // 真正传进来的参数个数(only x, y)
      alert(arguments.length); // 2

      // 参数的callee是函数自身
      alert(arguments.callee === foo); // true

      // 参数共享

      alert(x === arguments[0]); // true
      alert(x); // 10

      arguments[0] = 20;
      alert(x); // 20

      x = 30;
      alert(arguments[0]); // 30

      // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的

      z = 40;
      alert(arguments[2]); // undefined

      arguments[2] = 50;
      alert(z); // 40
    }

    foo(10, 20);
    ```

  - 当进入执行上下文(代码执行之前)时，VO 里已经包含了下列属性(前面已经说了)：
    - 函数的所有形参(如果我们是在函数执行上下文中)
      - 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和 undefined 值组成的一种变量对象的属性也将被创建。
    - 所有函数声明(FunctionDeclaration, FD)
      - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。
    - 所有变量声明(var, VariableDeclaration)
      - 由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。
  - 变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个进入上下文阶段，变量声明不会干扰 VO 中已经存在的同名函数声明或形式参数声明

[Javascript 函数声明的优先级高于变量声明的优先级，但不会覆盖变量赋值](https://blog.csdn.net/wy818/article/details/49247675)

### 执行上下文

#### [前端基础进阶（二）：执行上下文详细图解](https://www.jianshu.com/p/a6d37c77e8db)

- JS 运行环境大概包括三种情况：
  - 全局环境： JavaScript 代码运行起来会首先进入该环境
  - 函数环境：当函数被调用执行时，会进入当前函数中执行代码
  - eval（不建议使用，可忽略）

因此在一个 JavaScript 程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript 引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。

- 全局上下文在浏览器窗口关闭后出栈。
- 函数中，遇到 return 能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。

#### [JavaScript 深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)

```js
var scope = "global scope";

function checkScope() {
  var scope = "local scope";

  function f() {
    return scope;
  }

  return f();
}

checkScope(); // local scope
```

```js
var scope = "global scope";
function checkScope() {
  var scope = "local scope";

  function f() {
    return scope;
  }

  return f;
}

checkScope()(); // local scope
```

#### [什么是作用域和执行上下文](https://segmentfault.com/a/1190000009522006)

## 调用栈

可以使用断点（debugger) 或者 console.trace() 来查看调用栈信息

调用栈大小有两个指标： 最大栈容量和最大调用深度。满足其中一个就会栈溢出。

- 栈溢出

  调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出

- 尾递归优化（TCO）

  ```js
  function runStack(n) {
    if (n === 0) return 100;
    return runStack(n - 2);
  }
  runStack(50000);
  ```

  各大浏览器（除了 safari）没有部署尾调用优化

  V8 引擎实际上已经实现了尾调用优化，但是默认是关闭该功能的

  - [尾递归的后续探究](https://imweb.io/topic/5a244260a192c3b460fce275)

## 块级作用域

正是由于 JavaScript 存在变量提升这种特性，从⽽导致了很多与直觉不符的代码，这也是 JavaScript 的⼀个重要设计缺陷。

由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。

- 作用域

  作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量和函数的可⻅性和⽣命周期。

  - 全局作用域
  - 函数作用域
  - 块级作用域

    ```js
    function foo() {
      var a = 1;
      let b = 2;
      {
        let b = 3;
        var c = 4;
        let d = 5;
        console.log(a);
        console.log(b);
      }
      console.log(b);
      console.log(c);
      console.log(d);
    }
    foo();
    ```

    - 编译并创建执行上下文
      ![刚执⾏时 foo 函数的执⾏上下⽂](../imgs/browser/刚执⾏时%20foo%20函数的执⾏上下⽂.png)

      - 函数内部通过 var 声明的变量，在编译阶段全部被放到**变量环境**中
      - 通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中

      ![执⾏ foo 函数内部作⽤域块时的执⾏上下⽂](../imgs/browser/执⾏%20foo%20函数内部作⽤域块时的执⾏上下⽂.png)

      在词法环境内部维护了一个小型栈结构，栈底是函数最外层的变量，进入一个块级作用域后，就会把该作用域快内部的变量压到栈顶；当作用域执行完成后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构

## 作用域链

在 JavaScript 执行过程中，其作用域链是由词法作用域决定的

- 词法作用域

  词法作⽤域就是指**作⽤域是由代码中函数声明的位置来决定的**，所以词法作⽤域是**静态的作⽤域**，通过它就能够预测代码在执⾏过程中如何查找标识符。

- 闭包

  本来函数外部是无权访问函数内部的函数或者变量，但是通过外部变量引用或者返回函数方式使得函数能够在外部调用，在调用时执行上下文创建和执行过程中保留了变量对象和作用域链使其不会被垃圾回收的过程就是闭包

[前端基础进阶（六）：在 chrome 开发者工具中观察函数调用栈、作用域链与闭包](https://www.jianshu.com/p/73122bb3d262)

## this

在对象内部的⽅法中使⽤对象内部的属性是⼀个⾮常普遍的需求。但是 JavaScript 的作⽤域机制并不⽀持这⼀点，基于这个需求，JavaScript ⼜搞出来另外⼀套 this 机制。

![执行上下文](../imgs/browser/执行上下文.png)

- [彻底理解 js 中 this 的指向，不必硬背。](https://www.cnblogs.com/pssp/p/5216085.html)
- [彻底理解 JavaScript 中的 this](https://juejin.im/post/5c049e6de51d45471745eb98)

## 栈空间和堆空间

### 语言类型

- 在使⽤之前就需要确认其变量数据类型的称为静态语⾔。相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为动态语⾔。
- 偷偷转换的操作称为隐式类型转换。⽀持隐式类型转换的语⾔称为弱类型语⾔，不⽀持隐式类型转换的语⾔称为强类型语⾔。

![语⾔类型图](../imgs/browser/语⾔类型图.png)

### 内存空间

- 代码空间： 存储可执⾏代码
- 栈空间
  - JavaScript 引擎需要⽤栈来维护程序执⾏期间上下⽂的状态，如果栈空间⼤了话，所有的数据都存放在栈空间⾥⾯，那么会影响到上下⽂切换的效率，进⽽⼜影响到整个程序的执⾏效率
  - ESP（记录当前执⾏状态的指针），指向当前的执行上下文。当当前的函数执行结束后，JavaScript 会将 ESP 下移（上下文出栈）。上⾯的执⾏上下⽂虽然保存在栈内存中，但是已经是⽆效内存了。⽐如当调⽤另外⼀个函数时，这块内容会被直接覆盖掉，⽤来存放另外⼀个函数的执⾏上下⽂。
- 堆空间
  - 分代垃圾回收

[前端基础进阶：详细图解 JavaScript 内存空间](https://juejin.im/entry/589c29a9b123db16a3c18adf)

在 JS 中，每一个数据都需要一个内存空间。内存空间又被分为两种，栈内存(stock)与堆内存(heap)。

- 基础数据类型，这些值都有固定的大小，往往都保存在栈内存中，由系统自动分配存储空间。可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问。
- 引用数据类型，比如数组 Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。

## 编译器和解释器

### 语言分类

按语⾔的执⾏流程，可以把语⾔划分为编译型语⾔和解释型语⾔。

![编译器和解释器“翻译”代码](../imgs/browser/编译器和解释器“翻译”代码.png)

- 编译型语⾔

  在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂件，这样每次运⾏程序时，都可以直接运⾏该⼆进制⽂件，⽽不需要再次重新编译了。⽐如 C/C++、GO 等都是编译型语⾔。

- 解释型语⾔

  在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏

### V8 执行 JavaScript 的过程

![V8 执⾏⼀段代码流程图](../imgs/browser/V8%20执⾏⼀段代码流程图.png)

- ⽣成抽象语法树（AST）和执⾏上下⽂
  - 词法分析
    将一行行的源码拆解成一个个的 token
  - 语法分析
  - 有了 AST 之后生成该段代码的执行上下文
- 生成字节码

  > 字节码就是介于 AST 和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其转换为机器码后才能执⾏。

  解释器 Ignition 会根据 AST ⽣成字节码，并解释执⾏字节码。

  ⼀开始 V8 并没有字节码，⽽是直接将 AST 转换为机器码，由于执⾏机器码的效率是⾮常⾼效的，所以这种⽅式在发布后的⼀段时间内运⾏效果是⾮常好的。但是随着 Chrome 在⼿机上⼴泛普及，特别是运⾏在 512M 内存的⼿机上，内存占⽤问题也暴露出来了，因为 **V8 需要消耗⼤量的内存来存放转换后的机器码**。为了解决内存占⽤问题，V8 团队⼤幅重构了引擎架构，引⼊字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

  机器码所占⽤的空间远远超过了字节码，所以使⽤字节码可以减少系统的内存使⽤。

- 执行代码

  如果有⼀段第⼀次执⾏的字节码，解释器 Ignition 会逐条解释执⾏。到了这⾥，相信你已经发现了，解释器 Ignition 除了负责⽣成字节码之外，它还有另外⼀个作⽤，就是解释执⾏字节码。在 Ignition 执⾏字节码的过程中，如果发现有热点代码（HotSpot），⽐如⼀段代码被重复执⾏多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。

![即时编译（JIT）技术](../imgs/browser/即时编译（JIT）技术.png)

> bytecode 会比源文件大得多，会增加 loading 时间，v8 团队认为没必要

> 热点代码编译为机器码后以哈希表的形式存在 v8 的堆内存中

## 消息队列和事件循环

### 消息队列

消息队列是一种数据结构，可以存放要执行的任务。符合队列先进先出的特点

按照不同的任务类型来划分任务优先级，不过由于采⽤的静态优先级策略，对于其他⼀些场景，这种静态调度的策略并不是太适合。

我们基于不同的场景来动态调整消息队列的优先级.

在某个状态下，⼀直有新的⾼优先级的任务加⼊到队列中，这样就会导致其他低优先级的任务得不到执⾏，这称为任务饿死。

为了解决任务饿死的问题，我们给每个队列⼀个权重，如果连续执⾏了⼀定个数的⾼优先级的任务，那么中间会执⾏⼀次低优先级的任务，这样我们就完成了 Chromium 的任务改造。

### 事件循环

#### setTimeout

<!-- 存放 setTimeout 任务的队列其实是一个 hashmap 结构，等到执行这个结构的时候，会计算 hashmap 中的每个任务是否到期了，到期了就去执⾏，直到所有到期的任务都执⾏结束，才会进⼊下⼀轮循环 -->

定时器线程负责计时，到点了就把回调函数 push 到队列中

- 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
- 未激活的⻚⾯，setTimeout 执⾏最⼩间隔是 1000 毫秒（⽬的是为了优化后台⻚⾯的加载损耗以及降低耗电量）
- 延时执⾏时间有最⼤值

  Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最⼤只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值⼤于 2147483647 毫秒（⼤约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被⽴即执⾏。

  ```js
  function showName() {
    console.log("showName called");
  }
  var timeID = setTimeout(showName, 2147483648); //会被立即调⽤执⾏
  ```

- setTimeout VS requestAnimationFrame

  当显示器将⼀帧画⾯绘制完成后，并在准备读取下⼀帧之前，显示器会发出⼀个垂直同步信号（vertical synchronization）给 GPU，简称 VSync。

  CSS 动画是由渲染进程⾃动处理的，所以渲染进程会让 CSS 渲染每帧动画的过
  程与 VSync 的时钟保持⼀致, 这样就能保证 CSS 动画的⾼效率执⾏。

  但是 JavaScript 是由⽤户控制的，如果采⽤ setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持⼀致的，所以 JavaScript 中⼜引⼊了 window.requestAnimationFrame，⽤来和 VSync 的时钟周期同步。

## 渲染流水线下的 CSS

![含有 CSS 的⻚⾯渲染流⽔线](../imgs/browser/含有CSS的页面渲染流水线.jpg)

⾸先是发起主⻚⾯的请求，这个发起请求⽅可能是渲染进程，也有可能是浏览器进程，发起的请求被送到⽹络进程中去执⾏。⽹络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这⾥你需要特别注意下，请求 HTML 数据和构建 DOM 中间有⼀段空闲时间，这个空闲时间有可能成为⻚⾯渲染的瓶颈。

当渲染进程接收 HTML ⽂件字节流时，会先开启⼀个**预解析线程**，如果遇到 JavaScript ⽂件或者 CSS ⽂件，那么预解析线程会提前下载这些数据。对于上⾯的代码，预解析线程会解析出来⼀个外部的 theme.css ⽂件，并发起 theme.css 的下载。这⾥也有⼀个空闲时间需要你注意⼀下，就是在 DOM 构建结束之后、theme.css ⽂件还未下载完成的这段时间内，渲染流⽔线⽆事可做，因为下⼀步是合成布局树，⽽合成布局树需要 CSSOM 和 DOM，所以这⾥需要等待 CSS 加载结束并解析成 CSSOM。

和 DOM ⼀样，CSSOM 也具有两个作⽤，第⼀个是**提供给 JavaScript 操作样式表的能⼒**，第⼆个是**为布局树的合成提供基础的样式信息**。这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

在执⾏ JavaScript 脚本之前，如果⻚⾯中包含了外部 CSS ⽂件的引⽤，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能⼒，所以在执⾏ JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的⽣成。

```css
// theme.css
div {
  color: green;
  background-color: black;
}
```

```js
// foo.js
console.log('script)
```

```html
<html>
  <head>
    <link href="theme.css" rel="stylesheet" />
  </head>
  <body>
    <div>geekbang com</div>
    <script src="foo.js"></script>
    <div>geekbang com</div>
  </body>
</html>
```

![含有 JavaScript ⽂件和 CSS ⽂件⻚⾯的渲染流⽔线](../imgs/browser/含有%20JavaScript%20⽂件和%20CSS%20⽂件⻚⾯的渲染流⽔线.png)

在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS ⽂件和 JavaScript ⽂件需要下载，然后就同时发起这两个⽂件的下载请求，需要注意的是，这两个⽂件的下载过程是重叠的，所以下载时间按照最久的那个⽂件来算。

### 缩短白屏时间

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的⽂件下载，这样获取到 HTML ⽂件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少⽂件⼤⼩，⽐如通过 webpack 等⼯具移除⼀些不必要的注释，并压缩 JavaScript ⽂件。
- 将⼀些不需要在解析 HTML 阶段使⽤的 JavaScript 标记上 sync 或者 defer。
- 对于⼤的 CSS ⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的 CSS ⽂件，这样只有在特定的场景下才会加载特定的 CSS ⽂件。

## 分层和合成机制：为什么 CSS 动画⽐ JavaScript ⾼效

- 显示器是怎么显示图像的

  每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图⽚，更新的图⽚都来⾃于显卡中⼀个叫**前缓冲区**的地⽅，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。

- 显卡做什么

  显卡的职责就是合成新的图像，并将图像保存到**后缓冲区**中，⼀旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是⼀致的。但有时候，在⼀些复杂的场景中，显卡处理⼀张图⽚的速度会变慢，这样就会造成视觉上的卡顿。

- 帧 VS 帧率

  通过滚动条滚动⻚⾯，或者通过⼿势缩放⻚⾯时，屏幕上就会产⽣动画的效果。之所以能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流⽔线⽣成新的图⽚，并发送到显卡的后缓冲区。

  我们把渲染流⽔线⽣成的每⼀副图⽚称为⼀帧，把渲染流⽔线每秒更新了多少帧称为帧率。

### Chrome 中的合成技术，可以⽤三个词来概括总结：分层、分块和合成

- 分层和合成

  一些复杂的动效，如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这中绘制策略会严重影响页面的渲染效率。

  为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。

  需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线程执⾏的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执⾏的原因。

- 分块

  如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层⾯提升了渲染效率。

  合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块，这样
  就可以⼤⼤加速⻚⾯的显示速度。即使只绘制那些优先级最⾼的图块，也要耗费不少的时间，因为涉及到⼀个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会⽐较慢。

  为了解决这个问题，Chrome ⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚。⽐如可以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。在⾸次显示⻚⾯内容的时候，将这个低分辨率的图⽚显示出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显示的低分辨率内容。这种⽅式尽管会让⽤户在开始时看到的是低分辨率的内容，但是也⽐⽤户在开始时什么都看不到要好。

### 利⽤分层技术优化代码

```css
.box {
  will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做⼏何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现⼀层，等这些变换发⽣时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就⼤⼤提升了渲染的效率。这也是 CSS 动画⽐ JavaScript 动画⾼效的原因。

每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存，所以你需要恰当地使⽤ will-change。

## 优化⻚⾯性能

### 加载阶段

减少关键资源个数， 降低关键资源⼤⼩，降低关键资源的 RTT（Round Trip Time）次数。

- RTT：表示从发送端发送数据开始，到发送端收到来⾃接收端的确认，总共经历的时延

### 交互阶段

- 减少 JavaScript 脚本执⾏时间
  - 将⼀次执⾏的函数分解为多个任务，使得每次的执⾏时间不要过久。
  - 采⽤ Web Workers。你可以把 Web Workers 当作主线程之外的⼀个线程，在
    Web Workers 中是可以执⾏ JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是⽆法通过 JavaScript 来访问 DOM 的，所以我们可以把⼀些和 DOM 操作⽆关且耗时的任务放到 Web Workers 中去执⾏。
- 避免强制同步布局

  main_div.offsetHeight， 如果要获取到 main_div 的⾼度，就需要重新布局

- 避免布局抖动

  所谓布局抖动，是指在⼀次 JavaScript 执⾏过程中，多次执⾏强制布局和抖动操作。

  ```js
  function foo() {
    let time_li = document.getElementById("time_li");
    for (let i = 0; i < 100; i++) {
      let main_div = document.getElementById("mian_div");
      let new_node = document.createElement("li");
      let textnode = document.createTextNode("time.geekbang");
      new_node.appendChild(textnode);
      new_node.offsetHeight = time_li.offsetHeight;
      document.getElementById("mian_div").appendChild(new_node);
    }
  }
  ```

  我们在⼀个 for 循环语句⾥⾯不断读取属性值，每次读取属性值之前都要进⾏计算样式和布局。

- 合理利⽤ CSS 合成动画

## vDOM

### 双缓存

使⽤双缓存，可以让你先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显示缓冲区，这样就使得整个图像的输出⾮常稳定。

虚拟 DOM 看成是 DOM 的⼀个 buffer，和图形显示⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到 DOM 上，这样就能减少⼀些不必要的更新，同时还能保证 DOM 的稳定输出。

### 基于 React 和 Redux 构建 MVC 模型

![基于 React 和 Redux 构建 MVC 模型](../imgs/browser/基于%20React%20和%20Redux%20构建%20MVC%20模型.png)

## PWA

通过引⼊ Service Worker 来试着解决离线存储和消息推送的问题，通过引⼊ manifest.json 来解决⼀级⼊⼝的问题

- Service Worker
  在⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求。

  Web Worker 的⽬的是让 JavaScript 能够运⾏在⻚⾯主线程之外，不过由于 Web Worker 中是没有当前⻚⾯的 DOM 环境的，所以在 Web Worker 中只能执⾏⼀些和 DOM ⽆关的 JavaScript 脚本，并通过 postMessage ⽅法将执⾏的结果返回给主线程.

  在 Chrome 中， Web Worker 其实就是在渲染进程中开启的⼀个新线程，它的⽣命周期是和⻚⾯关联的。

  “让其运⾏在主线程之外”就是 Service Worker 来⾃ Web Worker 的⼀个核⼼思想。

  Web Worker 是临时的，每次 JavaScript 脚本执⾏完成之后都会退出，执⾏结果也不能保存下来，如果下次还有同样的操作，就还得重新来⼀遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。

  由于 Service Worker 还需要会为多个⻚⾯提供服务，所以还不能把 Service
  Worker 和单个⻚⾯绑定起来

  要使站点⽀持 Service Worker，⾸先必要的⼀步就是要将站点升级到 HTTPS。除了必须要使⽤ HTTPS，Service Worker 还需要同时⽀持 Web ⻚⾯默认的安全策略、同源策略、内容安全策略（CSP）等

## WebComponent

- 阻碍前端组件化的因素
  - CSS 是影响全局的
  - ⻚⾯中只有⼀个 DOM，任何地⽅都可以直接读取和修改 DOM
- WebComponent 给出了解决思路，它提供了对局部视图封装能⼒，可以让 DOM、
  CSSOM 和 JavaScript 运⾏在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。
- WebComponent 是⼀套技术的组合，具体涉及到了 Custom elements（⾃定义元素）、Shadow DOM（影⼦ DOM）和 HTML templates（HTML 模板）

```html
<!DOCTYPE html>
<html>
  <body>
    <!--
⼀：定义模板
⼆：定义内部CSS样式
三：定义JavaScript⾏为
-->
    <template id="geekbang-t">
      <style>
        p {
          background-color: brown;
          color: cornsilk;
        }
        div {
          width: 200px;
          background-color: bisque;
          border: 3px solid chocolate;
          border-radius: 10px;
        }
      </style>
      <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
      </div>
      <script>
        function foo() {
          console.log("inner log");
        }
      </script>
    </template>
    <script>
      class GeekBang extends HTMLElement {
        constructor() {
          super();
          //获取组件模板
          const content = document.querySelector("#geekbang-t").content;
          //创建影⼦DOM节点
          const shadowDOM = this.attachShadow({ mode: "open" });
          //将模板添加到影⼦DOM上
          shadowDOM.appendChild(content.cloneNode(true));
        }
      }
      customElements.define("geek-bang", GeekBang);
    </script>
    <geek-bang></geek-bang>
    <div>
      <p>time.geekbang.org</p>
      <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
  </body>
</html>
```

- ShadowDOM 的作⽤是将模板中的内容与全局 DOM 和 CSS 进⾏隔离，这样我们就可以实现元素和样式的私有化了

## 安全

- [前端安全知多少](https://juejin.im/entry/598d6eb46fb9a03c3a25d2c1)

### 同源策略

如果两个 URL 的协议、域名和端⼝都相同，我们就称这两个 URL 同源。

浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有⼀套基础的安全策略的制约，我们把这称为同源策略。

- 同源策略主要表现在 DOM、Web 数据和⽹络这三个层⾯
  - DOM
    同源策略限制了来⾃不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
  - 数据
    同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
  - 网络
    同源策略限制了通过 XMLHttpRequest 等⽅式将站点的数据发送给不同源的站点。

### 跨域资源共享(CORS)和跨⽂档消息机制(window.postMessage)

### 跨站脚本攻击（XSS: Cross Site Scripting）

- [如何防止 XSS 攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)

Cross-Site Scripting（跨站脚本攻击）简称 XSS，为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

- 如果⻚⾯被注⼊了恶意 JavaScript 脚本，恶意脚本都能做哪些事情

  - 窃取 Cookie 信息
    恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到⽤户的 Cookie 信息之后，就可以在其他电脑上模拟⽤户的登录，然后进⾏转账等操作。
  - 监听⽤户⾏为
    恶意 JavaScript 可以使⽤“addEventListener”接⼝来监听键盘事件，⽐如可以获取⽤户输⼊的信⽤卡等信息，将其发送到恶意服务器。⿊客掌握了这些信息之后，⼜可以做很多违法的事情。
  - 修改 DOM
    可以通过修改 DOM 伪造假的登录窗⼝，⽤来欺骗⽤户输⼊⽤户名和密码等信息。
  - 在⻚⾯内⽣成浮窗⼴告

- XSS 分类

  - 存储型 XSS：

    存储型 XSS 的攻击步骤：

    1. 攻击者将恶意代码提交到目标网站的数据库中。
    2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
    3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
    4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

    这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

  - 反射型 XSS:

    反射型 XSS 的攻击步骤：

    1. 攻击者构造出特殊的 URL，其中包含恶意代码。
    2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
    3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
    4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

    > 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

    反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

    由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

    POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

  - DOM 型 XSS:

    DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

    ⿊客通过各种⼿段将恶意脚本注⼊⽤户的⻚⾯中，⽐如通过⽹络劫持在⻚⾯传输过程中修改 HTML ⻚⾯的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在⽤户使⽤⻚⾯的过程中修改 Web ⻚⾯的数据。

    ```html
    <script>
      eval(location.hash.substr(1));
      // 而这个时候，如果用户在网址后面加上恶意代码
      ("http://www.xss.com#alert(document.cookie)");
    </script>
    ```

- XSS 预防：

  1. 输入过滤，转义(html 转义为实体)输出、存储
  2. 在标签的 href、src 等属性中，包含 `javascript:` 等可执行代码。
  3. 避免使用 eval，new Function 等执行字符串的方法，除非确定字符串和用户输入无关。
     `new Function ([arg1[, arg2[, ...argN]],] functionBody)`
  4. 使用 innerHTML，document.write 的时候，如果数据是用户输入的，那么需要对关键字符都进行过滤与转义。
  5. 对于非客户端 cookie，比如保存用户凭证的 session，务必标识为 http only，这样 js 就获取不到这个 cookie 值了，安全性得到提高。
  6. X-XSS-Protection
  7. cookie secure\httpOnly
  8. 内容安全策略(CSP)

     CSP 的核⼼思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执⾏内联 JavaScript 代码

### 跨站请求伪造 CSRF(Cross-site request forgery)

CSRF 攻击就是⿊客利⽤了⽤户的登录状态，并通过第三⽅的站点来做⼀些坏事。

- ⾃动发起 Get 请求

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <h1>⿊客的站点：CSRF攻击演示</h1>
      <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100" />
    </body>
  </html>
  ```

- ⾃动发起 POST 请求

  ```html
  <!DOCTYPE html>
  <html>
    <body>
      <h1>⿊客的站点：CSRF攻击演示</h1>
      <form
        id="hacker-form"
        action="https://time.geekbang.org/sendcoin"
        method="POST"
      >
        <input type="hidden" name="user" value="hacker" />
        <input type="hidden" name="number" value="100" />
      </form>
      <script>
        document.getElementById("hacker-form").submit();
      </script>
    </body>
  </html>
  ```

- 引诱⽤户点击链接

  ```html
  <div>
    <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg />
    <a
      href="https://time.geekbang.org/sendcoin?user=hacker&number=100"
      taget="_blank"
    >
      点击下载美⼥照⽚
    </a>
  </div>
  ```

- [浅谈 CSRF 攻击方式](https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html)
- [跨站请求伪造与 Same-Site Cookie](https://www.jianshu.com/p/66f77b8f1759)
- 预防
  - 检测 http referer 是否是同域名，通常来讲，用户提交的请求，referer 应该是来来自站内地址，所以如果发现 referer 中地址异常，那么很可能是遭到了 CSRF 攻击。
    - 在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会⼜制定了 Origin 属性，在⼀些重要的场合，⽐如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post ⽅法发送请求时，都会带上 Origin 属性
    - Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的⼀个主要区别
    - 服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使⽤ Referer 值。
  - 避免登录的 session 长时间存储在客户端中。
  - 关键请求使用验证码或者 token 机制。在一些十分关键的操作，比如交易付款环节。这种请求中，加入验证码，可以防止被恶意用户攻击。token 机制也有一定的防御作用。具体来说就是服务器每次返回客户端页面的时候，在页面中埋上一个 token 字段，例如 `<input type=“hidden” name=“csrftoken” value=“abcd">`。 之后，客户端请求的时候带上这个 token，使用这个机制后，攻击者也就很难发起 CSRF 攻击了。
  - sameSite cookie

### 浏览器架构

通过浏览器漏洞进⾏的攻击是可以⼊侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在⽤户的操作系统上悄悄地安装恶意软件、监听⽤户键盘输⼊信息以及读取⽤户硬盘上的⽂件内容。

所有的⽹络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进⾏解析、绘制等操作，最终⽣成⼀幅图⽚。但是渲染进程并不负责将图⽚显示到界⾯上，⽽是将最终⽣成的图⽚提交给浏览器内核模块，由浏览器内核模块负责显示这张图⽚。

浏览器可以安全地下载各种⽹络资源，但是如果要执⾏这些⽹络资源，⽐如解析 HTML、解析 CSS、执⾏ JavaScript、图⽚编解码等操作，就需要⾮常谨慎了，因为⼀不⼩⼼，⿊客就会利⽤这些操作对含有漏洞的浏览器发起攻击。

我们需要在渲染进程和操作系统之间建⼀道墙，即便渲染进程由于存在漏洞被⿊客攻击，但由于这道墙，⿊客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。

浏览器中的安全沙箱是利⽤操作系统提供的安全技术，让渲染进程在执⾏过程中⽆法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最⼩的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是⽆法被安全沙箱保护的，⽽现代浏览器采⽤的多进程架构使得安全沙箱可以发挥作⽤。

我们知道安全沙箱最⼩的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应⽤在某个进程上，那么这个进程必须没有读写操作系统的功能，⽐如读写本地⽂件、发起⽹络请求、调⽤ GPU 接⼝等。

![浏览器内核和渲染进程各⾃职责](../imgs/browser/浏览器内核和渲染进程各⾃职责.png)

- 安全沙箱是如何影响到各个模块功能的呢

  - 持久存储

    我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程⽆法直接访问⽤户的⽂件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传⽂件的需求，为了解决这些⽂件的访问需求，所以现代浏览器将读写⽂件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。

    - 存储 Cookie 数据的读写。通常浏览器内核会维护⼀个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。
    - ⼀些缓存⽂件的读写也是由浏览器内核实现的，⽐如⽹络⽂件缓存的读取。

  - ⽹络访问

    在渲染进程内部也是不能直接访问⽹络的，如果要访问⽹络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，⽐如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求

  - ⽤户交互

    通常情况下，如果你要实现⼀个 UI 程序，操作系统会提供⼀个界⾯给你，该界⾯允许应⽤程序与⽤户交互，允许应⽤程序在该界⾯上进⾏绘制，⽐如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗⼝句柄。应⽤程序可以在窗⼝句柄上进⾏绘制和接收键盘⿏标消息

    由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是⽆法直接操作窗⼝句柄的，这也是为了限制渲染进程监控到⽤户的输⼊事件。

    - 渲染进程需要渲染出位图。为了向⽤户显示渲染进程渲染出来的位图，渲染进程需要将⽣成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。
    - 操作系统没有将⽤户输⼊事件直接传递给渲染进程，⽽是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界⾯的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输⼊事件会在浏览器内核内部处理；如果当前焦点在⻚⾯的区域内，则浏览器内核会将输⼊事件转发给渲染进程。(之所以这样设计，就是为了限制渲染进程有监控到⽤户输⼊事件的能⼒，所以所有的键盘⿏标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。)

- 站点隔离（Site Isolation）

  所谓站点隔离是指 Chrome 将同⼀站点（包含了相同根域名和相同协议的地址）中相互关联的⻚⾯放到同⼀个渲染进程中执⾏。

  最开始 Chrome 划分渲染进程是以标签⻚为单位，也就是说整个标签⻚会被划分给某个渲染进程。但是，按照标签⻚划分渲染进程存在⼀些问题，原因就是⼀个标签⻚中可能包含了多个 iframe，⽽这些 iframe ⼜有可能来⾃于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运⾏在同⼀个渲染进程中。

  Chrome ⼏年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同⼀站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。

  实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它⽆法继续访问其他 iframe 进程的内容，因此也就⽆法攻击其他站点了。

### HTTPS

- 中间⼈攻击

  在将 HTTP 数据提交给 TCP 层之后，数据会经过⽤户电脑、WiFi 路由器、运营商和⽬标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。⽐如⽤户电脑被⿊客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者⽤户⼀不⼩⼼连接上了 WiFi 钓⻥路由器，那么数据也都能被⿊客抓取或篡改。

- 对称加密

  ![使⽤对称加密实现 HTTPS](../imgs/browser/使⽤对称加密实现%20HTTPS.png)

  - 浏览器发送它所⽀持的加密套件列表和⼀个随机数 client-random，这⾥的加密套件是指加密的⽅法，加密套件列表就是指浏览器能⽀持多少种加密⽅法列表。
  - 服务器会从加密套件列表中选取⼀个加密套件，然后还会⽣成⼀个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。
  - 最后浏览器和服务器分别返回确认消息。

  这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使⽤相同的⽅法将 client-random 和 service-random 混合起来⽣成⼀个密钥 mastersecret，有了密钥 master secret 和加密套件之后，双⽅就可以进⾏数据的加密传输了。

  > 其中传输 client-random 和 service-random 的过程却是明⽂的，这意味着⿊客也可以拿到协商的加密套件和双⽅的随机数，由于利⽤随机数合成密钥的算法是公开的，所以⿊客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么⿊客也就可以使⽤密钥来伪造或篡改数据了

- ⾮对称加密

  ![⾮对称加密实现 HTTPS](../imgs/browser/⾮对称加密实现%20HTTPS.png)

  - ⾸先浏览器还是发送加密套件列表给服务器。
  - 然后服务器会选择⼀个加密套件，不过和对称加密不同的是，使⽤⾮对称加密时服务器上需要有⽤于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使⽤的，因此服务器会将加密套件和公钥⼀道发送给浏览器。
  - 最后就是浏览器和服务器返回确认消息。

  这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使⽤该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便⿊客截获了数据和公钥，他也是⽆法使⽤公钥来解密数据的。

  - 存在两个严重的问题

    - ⾮对称加密的效率太低: 严重影响到加解密数据的速度，进⽽影响到⽤户打开⻚⾯的速度。
    - ⽆法保证服务器发送给浏览器的数据安全。

- 混合加密实现 HTTPS

  在传输数据阶段依然使⽤对称加密，但是对称加密的密钥我们采⽤⾮对称加密来传输。

  ![混合加密实现 HTTPS](../imgs/browser/混合加密实现%20HTTPS.png)

  - ⾸先浏览器向服务器发送**对称加密套件列表**、**⾮对称加密套件列表**和**随机数 client-random**；
  - 服务器保存随机数 client-random，选择对称加密和⾮对称加密的套件，然后⽣成随机数 service-random，向浏览器发送选择的**加密套件**、**service-random** 和**公钥**；
  - 浏览器保存公钥，并⽣成随机数 pre-master，然后**利⽤公钥对 pre-master 加密**，并向服务器发送加密后的数据；
  - 最后服务器拿出⾃⼰的私钥，解密出 pre-master 数据，并返回确认消息。

  到此为⽌，服务器和浏览器就有了共同的 client-random、service-random 和 premaster，然后服务器和浏览器会使⽤这三组随机数⽣成对称密钥，因为服务器和浏览器使⽤同⼀套⽅法来⽣成密钥，所以最终⽣成的密钥也是相同的。双⽅就可以使⽤对称加密的⽅式来传输数据了。

- 添加数字证书

  混合加密实现 HTTPS ⽅式依然存在着问题，⽐如我要打开官⽹，但是⿊客通过 DNS 劫持将官⽹的 IP 地址替换成了⿊客的 IP 地址，这样我访问的其实是⿊客的服务器了，⿊客就可以在⾃⼰的服务器上实现公钥和私钥，⽽对浏览器来说，它完全不知道现在访问的是个⿊客的站点。

  ![完整的 HTTPS 请求流程](../imgs/browser/完整的%20HTTPS%20请求流程.png)

  - 服务器没有直接返回公钥给浏览器，⽽是返回了数字证书，⽽公钥正是包含在数字证书中的；
  - 在浏览器端多了⼀个证书验证的操作，验证了证书之后，才继续后续流程

  通过引⼊数字证书，我们就实现了服务器的身份认证功能，这样即便⿊客伪造了服务器，但是由于证书是没有办法伪造的，所以依然⽆法欺骗⽤户。

  数字证书，包含了网站的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明⽂的，同时包含⼀个 CA ⽣成的签名。

  数字签名过程：⾸先 CA 使⽤ Hash 函数来计算提交的明⽂信息，并得出信息摘要；然后 CA 再使⽤它的私钥对信息摘要进⾏加密，加密后的密⽂就是 CA 颁给的数字签名。

  - 数字证书的申请流程

    ![数字证书申请过程](../imgs/browser/数字证书申请过程.png)

    - ⾸先极客时间填写了⼀张含有⾃⼰身份信息的表单，身份信息包括了⾃⼰公钥、站点资料、公司资料等信息，然后将其提交给了 CA 机构；
    - CA 机构会审核表单中内容的真实性；
    - 审核通过后，CA 机构会拿出⾃⼰的私钥，对表单的内容进⾏⼀连串操作，包括了对明⽂资料进⾏ Hash 计算得出信息摘要，利⽤ CA 的私钥加密信息摘要得出数字签名，最后将数字签名也写在表单上，并将其返还给极客时间，这样就完成了⼀次数字证书的申请操作。

  - 浏览器验证证书的流程

    - 验证证书相关的域名信息
    - 第⼀部分就是验证证书的有效期。证书⾥⾯就含有证书的有效期，所以浏览器只需要判断当前时间是否在证书的有效期范围内即可。
    - 第⼆部分就是验证数字证书是否被吊销了。

      - 下载吊销证书列表 - CRL (Certificate Revocation Lists)
      - 在线验证⽅式 - OCSP (Online Certificate Status Protocol)

    - 验证极客时间的数字证书是否是 CA 机构颁发的，

      - 先浏览器读取证书中相关的明⽂信息，采⽤ CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；
      - 然后再利⽤对应 CA 的公钥解密签名数据，得到信息摘要 B
      - 对⽐信息摘要 A 和信息摘要 B，如果⼀致，则可以确认证书是合法的

  - 浏览器是如何获取 CA 公钥

    通常，当你部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的⼀些基础信息。

    服务器就有了两个数字证书：

    - 给域名的数字证书；
    - 给域名签名的 CA 机构的数字证书。

    如果有些服务器没有部署 CA 的数字证书，那么浏览器还可以通过⽹络去下载 CA 证书，不过这种⽅式多了⼀次证书下载操作，会拖慢⾸次打开⻚⾯的请求速度，⼀般不推荐使⽤。

  - 证书相关延伸阅读

    CA 是⼀个机构，它的职责是给⼀些公司或者个⼈颁发数字证书，在颁发证书之前，有⼀个重要的环节，就是审核申请者所提交资料的合法性和合规性。

    - 申请者的类型有很多：

      - 如果申请者是个⼈，CA 只需要审核域名的所有权就⾏了，审核域名所有权有很多中⽅法，最常⽤的⽅法是让申请者在域名上放⼀个⽂件，然后 CA 验证该⽂件是否存在，即可证明该域名是否是申请者的。我们把这类数字证书称为 DV，审核这种个⼈域名信息是最简单的，因此 CA 收取的费⽤也是最低的，有些 CA 甚⾄免费为个⼈颁发数字证书。

      - 如果申请者是普通公司，那么 CA 除了验证域名的所有权之外，还需要验证公司公司的合法性，这类证书通常称为 OV。由于需要验证公司的信息，所有需要额外的资料，⽽且审核过程也更加复杂，申请 OV 证书的价格也更⾼，主要是由于验证公司的合法性是需要⼈⼯成本的。如果申请者是⼀些⾦融机构、银⾏、电商平台等，所以还需额外的要验证⼀些经营资质是否合法合规，这类证书称为 EV。申请 EV 的价格⾮常⾼，甚⾄达到好⼏万⼀年，因为需要⼈⼯验证更多的内容。

    好了，我们了解了证书有很多种不同的类型，DV 这种就可以⾃动审核，不过 OV、EV 这种类型的证书就需要⼈⼯验证了，⽽每个地⽅的验证⽅式⼜可能不同，⽐如你是⼀家美国本地的 CA 公司，要给中国的⼀些⾦融公司发放数字证书，这过程中验证证书就会遇到问题，因此就需要本地的 CA 机构，他们验证会更加容易。

    因此，就全球就有很多家 CA 机构，然后就出现了⼀个问题，这些 CA 是怎么证明它⾃⼰是安全的？如果⼀个恶意的公司也成⽴了⼀个 CA 机构，然后给⾃⼰颁发证书，那么这就⾮常危险了，因此我们必须还要实现⼀个机制，让 CA 证明它⾃⼰是安全⽆公害的。

    这就涉及到数字证书链了。

    ![数字证书链](../imgs/browser/数字证书链.png)

    要讲数字证书链，就要了解我们的 CA 机构也是分两种类型的，中间 CA(Intermediates CAs) 和根 CA(Root CAs)，通常申请者都是向中间 CA 去申请证书的，⽽根 CA 作⽤就是给中间 CA 做认证，通常，⼀个根 CA 会认证很多中间的 CA，⽽这些中间 CA ⼜可以去认证其它的中间 CA。

    ⽐如你可以在 Chrome 上打开官⽹，然后点击地址栏前⾯的那把⼩锁，你就可以看到 `*.geekbang.org` 的证书是由中间 CA GeoTrust RSA CA2018 颁发的，⽽中间 CA GeoTrust RSACA2018 ⼜是由根 CA DigiCert Global Root CA 颁发的，所以这个证书链就是：`*.geekbang.org`--->`GeoTrust RSA CA2018`-->`DigiCert Global Root CA`。

    因此浏览器验证证书时，会先验证 `*.geekbang.org` 的证书，如果合法在验证中间 CA 的证书，如果中间 CA 也是合法的，那么浏览器会继续验证这个中间 CA 的根证书。

    这时候问题⼜来了，怎么证明根证书是合法的？

    浏览器的做法很简单，它会查找系统的根证书，如果这个根证书在操作系统⾥⾯，那么浏览器就认为这个根证书是合法的，如果验证的根证书不在操作系统⾥⾯，那么就是不合法的。

    ⽽操作系统⾥⾯这些内置的根证书也不是随便内置的，这些根 CA 都是通过 WebTrust 国际安全审计认证。

    WebTrust（⽹络信任）认证是电⼦认证服务⾏业中唯⼀的国际性认证标准，主要对互联⽹服务商的系统及业务运作的商业惯例和信息隐私，交易完整性和安全性。WebTrust 认证是各⼤主流的浏览器、微软等⼤⼚商⽀持的标准，是规范 CA 机构运营服务的国际标准。在浏览器⼚商根证书植⼊项⽬中，必要的条件就是要通过 WebTrust 认证，才能实现浏览器与数字证书的⽆缝嵌⼊。

    ⽬前通过 WebTrust 认证的根 CA 有 Comodo，geotrust，rapidssl，symantec，thawte，digicert 等。也就是说，这些根 CA 机构的根证书都内置在各⼤操作系统中，只要能从数字证书链往上追溯到这⼏个根证书，浏览器会认为使⽤者的证书是合法的。

## 性能评估

### 加载阶段的性能 -- 利⽤ Audits ⽣成 Web 性能报告

- ⾸先我们打开浏览器的隐身窗⼝，Windows 系统下⾯的快捷键是 Control+Shift+N，Mac 系统下⾯的快捷键是 Command+Shift+N
- 然后在隐身窗⼝中输⼊ B 站的⽹站。
- 打开 Chrome 的开发者⼯具，选择 Audits 标签。
- 我们需要先配置 Audits，配置模块主要有两部分组成，⼀个是监测类型 (Categories)，另外⼀个是设备类型(Device)。

  - 监控类型 (Categories) 是指需要监控哪些内容
    - 监测并分析 Web 性能 (Performance)；
    - 监测并分析 PWA(Progressive Web App) 程序的性能；
    - 监测并分析 Web 应⽤是否采⽤了最佳实践策略 (Best practices)；
    - 监测并分析是否实施了⽆障碍功能 (Accessibility)， ⽆障碍功能让⼀些身体有障碍的⼈可以⽅便地浏览你的 Web 应⽤。
    - 监测并分析 Web 应⽤是否采实施了 SEO 搜素引擎优化 (SEO)。
  - 设备类型(Device)
    - Moblie 选项是⽤来模拟移动设备环境
    - Desktop 选项是⽤来模拟桌⾯环境的

- 点击最上⾯的⽣成报告 (Generate report) 按钮来⽣成报告

  - ⾸次绘制 (First Paint)；

  - ⾸次有效绘制 (First Meaningfull Paint)

    由于 FMP 计算复杂，⽽且容易出错，现在不推荐使⽤该指标

  - ⾸屏时间 (Speed Index)；

    这就是我们上⾯提到的 LCP，它表示填满⾸屏⻚⾯所消耗的时间，⾸屏时间的值越⼤，那么加载速度越慢

  - ⾸次 CPU 空闲时间 (First CPU Idle)；

    它表示⻚⾯达到最⼩化可交互的时间，也就是说并不需要等到⻚⾯上的所有元素都可交互，只要可以对⼤部分⽤户输⼊做出响应即可

  - 完全可交互时间 (Time to Interactive)；

    它表示⻚⾯中所有元素都达到了可交互的时⻓。简单理解就这时候⻚⾯的内容已经完全显示出来了，所有的 JavaScript 事件已经注册完成，⻚⾯能够对⽤户的交互做出快速响应，通常满⾜响应速度在 50 毫秒以内。如果要解决 TTI 时间过久的问题，我们可以推迟执⾏⼀些和⽣成⻚⾯⽆关的 JavaScript ⼯作。

  - 最⼤估计输⼊延时 (Max Potential First Input Delay)。

    这个指标是估计你的 Web ⻚⾯在加载最繁忙的阶段， 窗⼝中响应⽤户输⼊所需的时间，为了改善该指标，我们可以使⽤ WebWorker 来执⾏⼀些计算，从⽽释放主线程。另⼀个有⽤的措施是重构 CSS 选择器，以确保它们执⾏较少的计算。

  ![⻚⾯加载过程](../imgs/browser/⻚⾯加载过程.png)

### ⻚⾯性能⼯具 -- Performance

Performance 可以记录站点在运⾏过程中的性能数据

不同于 Audits，Perofrmance 不会给出性能得分，也不会给出优化建议，它只是单纯地采集性能数据，并将采集到的数据按照时间线的⽅式来展现，我们要做的就是依据原始数据来分析 Web 应⽤的性能问题。

- 第⼀步是配置 Performance

  ![Performance 配置⻚](../imgs/browser/Performance%20配置⻚.png)

  1. 设置该区域中的“Network”来限制⽹络加载速度("快的 3G(Fast 3G)")，设置“CPU”来限制 CPU 的运算速度(降低到了 1/6)。

- 第⼆步是⽣成报告⻚

  - 2 区那个⿊⾊按钮是⽤来记录交互阶段性能数据的

    如果你是录制交互阶段的性能时，那么需要⼿动停⽌录制过程。

  - 2 区带箭头的圆圈形按钮⽤来记录加载阶段的性能数据。

    当你录制加载阶段的性能数据时，Performance 会重新刷新⻚⾯，并等到⻚⾯完全渲染出来后，Performance 就会⾃动停⽌录制。

- 第三步就是⼈⼯分析报告⻚，并找出⻚⾯的性能瓶颈。

  报告⻚分为三个主要的部分，分别为概览⾯板、性能指标⾯板和详情⾯板。

  ![Performance 的报告⻚](../imgs/browser/Performance%20的报告⻚.png)

  - 概览⾯板

    Performance 就会将⼏个关键指标，诸如⻚⾯帧速 (FPS)、CPU 资源消耗、⽹络请求流量、V8 内存使⽤量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览⾯板

    可能存在问题的时间节点

    - FPS 图表上出现了红⾊块，那么就表示红⾊块附近渲染出⼀帧所需时间过久，帧的渲染时间过久，就有可能导致⻚⾯卡顿
    - 如果 CPU 图形占⽤⾯积太⼤，表示 CPU 使⽤率就越⾼，那么就有可能因为某个 JavaScript 占⽤太多的主线程时间，从⽽影响其他任务的执⾏。
    - 如果 V8 的内存使⽤量⼀直在增加，就有可能是某种原因导致了内存泄漏。

    除了以上指标以外，概览⾯板还展示加载过程中的⼏个关键时间节点，如 FP、LCP、DOMContentLoaded、Onload 等事件产⽣的时间点。这些关键时间点体现在了⼏条不同颜⾊的竖线上。

  - 性能指标⾯板

    - Network 指标

      展示了⻚⾯中的每个⽹络请求所消耗的时⻓，并以瀑布流的形式展现、

    - Timings 指标

      记录⼀些关键的时间节点在何时产⽣的数据信息，诸如 FP、FCP、LCP 等

    - Frames 指标

      浏览器⽣成每帧的记录。帧记录就是⽤来记录渲染进程⽣成所有帧信息，包括了渲染出每帧的时⻓、每帧的图层构造等信息

    - Interactions 指标

      记录⽤户交互操作，⽐如点击⿏标、输⼊⽂字等交互信息。

    - Main 指标记录渲染主线程的任务执⾏过程

      每个灰⾊横条就对应了⼀个任务，灰⾊⻓条的⻓度对应了任务的执⾏时⻓。

      灰线下⾯的横条就是⼀个个过程，同样这些横条的⻓度就代表这些过程执⾏的时⻓。

      ![单个任务](../imgs/browser/单个任务.png)

      ```js
      function A() {
        A1();
        A2();
      }

      function Task() {
        A();
        B();
      }

      Task();
      ```

      - 分析⻚⾯加载过程

        ```html
        <html>
          <head>
            <title>Main</title>
            <style>
              area {
                border: 2px ridge;
              }
              box {
                background-color: rgba(106, 24, 238, 0.26);
                height: 5em;
                margin: 1em;
                width: 5em;
              }
            </style>
          </head>
          <body>
            <div class="area">
              <div class="box rAF"></div>
            </div>
            <br />
            <script>
              function setNewArea() {
                let el = document.createElement("div");
                el.setAttribute("class", "area");
                el.innerHTML = '<div class="box rAF"></div>';
                document.body.append(el);
              }
              setNewArea();
            </script>
          </body>
        </html>
        ```

        ⾸先⽣成报告⻚，再观察报告⻚中的 Main 指标，由于阅读实际指标⽐较费劲，所以我⼿动绘制了⼀些关键的任务和其执⾏过程，如下图所示：

        ![Main 指标](../imgs/browser/Main%20指标.png)

        1. 导航阶段，该阶段主要是从⽹络进程接收 HTML 响应头和 HTML 响应体

           - 该任务的第⼀个⼦过程就是 Send request，该过程表示⽹络请求已被发送。然后该任务进⼊了等待状态。

           - 接着由⽹络进程负责下载资源，当接收到响应头的时候，该任务便执⾏ Receive Respone 过程，该过程表示接收到 HTTP 的响应头了。

           - 接着执⾏ DOM 事件：pagehide、visibilitychange 和 unload 等事件，如果你注册了这些事件的回调函数，那么这些回调函数会依次在该任务中被调⽤。

           - 这些事件被处理完成之后，那么接下来就接收 HTML 数据了，这体现在了 Recive Data 过程，Recive Data 过程表示请求的数据已被接收，如果 HTML 数据过多，会存在多个 Receive Data 过程。

           - 等到所有的数据都接收完成之后，渲染进程会触发另外⼀个任务，该任务主要执⾏ Finish load 过程，该过程表示⽹络请求已经完成

        2. 解析 HTML 数据阶段，该阶段主要是将接收到的 HTML 数据转换为 DOM 和 CSSOM

           - 在 ParserHTML 的过程中，如果解析到了 script 标签，那么便进⼊了脚本执⾏过程，也就是图中的 Evalute Script。
           - 我们知道，要执⾏⼀段脚本我们需要⾸先编译该脚本，于是在 Evalute Script 过程中，先进⼊了脚本编译过程，也就是图中的 Complie Script。脚本编译好之后，就进⼊程序执⾏过程，执⾏全局代码时，V8 会先构造⼀个 anonymous 过程，在执⾏ anonymous 过程中，会调⽤ setNewArea 过程，setNewArea 过程中⼜调⽤了 createElement，由于之后调⽤了 document.append ⽅法，该⽅法会触发 DOM 内容的修改，所以⼜强制执⾏了 ParserHTML 过程⽣成的新的 DOM。
           - DOM ⽣成完成之后，会触发相关的 DOM 事件，⽐如典型的 DOMContentLoaded，还有 readyStateChanged。
           - DOM ⽣成之后，ParserHTML 过程继续计算样式表，也就是 Reculate Style，这就是⽣成 CSSOM 的过程

        3. 生成可显示的位图阶段，该阶段主要是利⽤ DOM 和 CSSOM，经过计算布局、⽣成层树 (LayerTree)、⽣成绘制列表 (Paint)、完成合成等操作，⽣成最终的图⽚

           1. ⾸先执 ⾏布局，这个过程对应图中的 Layout。
           2. 然后更新层树 (LayerTree)，这个过程对应图中的 Update LayerTree。
           3. 有了层树之后，就需要为层树中的每⼀层准备绘制列表了，这个过程就称为 Paint。
           4. 准备每层的绘制列表之后，就需要利⽤绘制列表来⽣成相应图层的位图了，这个过程对应图中的 Composite Layers。

           ⾛到了 Composite Layers 这步，主线程的任务就完成了，接下来主线程会将合成的任务完全教给合成线程来执⾏，下⾯是具体的过程，你也可以对照着 Composite、Raster 和 GPU 这三个指标来分析，参考下图：

           ![显示流程](../imgs/browser/显示流程.png)

           1. ⾸先主线程执⾏到 Composite Layers 过程之后，便会将绘制列表等信息提交给合成线程，合成线程的执⾏记录你可以通过 Compositor 指标来查看。
           2. 合成线程维护了⼀个 Raster 线程池，线程池中的每个线程称为 Rasterize，⽤来执⾏光栅化操作，对应的任务就是 Rasterize Paint。
           3. 当然光栅化操作并不是在 Rasterize 线程中直接执⾏的，⽽是在 GPU 进程中执⾏的，因此 Rasterize 线程需要和 GPU 线程保持通信。
           4. 然后 GPU ⽣成图像，最终这些图层会被提交给浏览器进程，浏览器进程将其合成并最终显示在⻚⾯上。

    - Compositor 指标记录了合成线程的任务执⾏过程

      如果合成线程直接和 GPU 进程进⾏通信，那么势必会阻塞后⾯的合成任务，因此合成线程⼜维护了⼀个光栅化线程池 (Raster)，⽤来让 GPU 执⾏光栅化的任务

    - Raster 指标记录光栅化线程池的任务执行过程

      点开 Raster 项，可以看到它维护了多个线程。

    - GPU 指标记录了 GPU 进程主线程的任务执⾏过程

    - Chrome_ChildIOThread 指标对应的就是 IO 线程的任务记录。

      渲染进程中除了有主线程、合成线程、光栅化线程池之外，还维护了⼀个 IO 线程，主要⽤来接收⽤户输⼊事件、⽹络事件、设备相关等事件，如果事件需要渲染主线程来处理，那么 IO 线程还会将这些事件转发给渲染主线程

- 详情⾯板
