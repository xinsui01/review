<!DOCTYPE html>
<html>
<head>
<title>learn.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<p><a href="https://juejin.im/post/5c64d15d6fb9a049d37f9c20">中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)</a></p>
<h1 id="javascript">JavaScript</h1>
<h2 id="var-let-%E5%8C%BA%E5%88%AB">var, let 区别</h2>
<ul>
<li>
<p>顶级作用域 var 声明变量是 window 的属性，let\const 声明变量不是 window 的属性，变量都可以在控制台访问。</p>
</li>
<li>
<p>let声明的变量拥有块级作用域，不存在变量提升</p>
</li>
<li>
<p>暂时性死区</p>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre class="hljs"><code><div>  var tmp = 123;

  if (true) {
    tmp = 'abc'; // ReferenceError
    let tmp;
  }
</div></code></pre>
</li>
<li>
<p>不允许重复声明</p>
</li>
</ul>
<h2 id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</h2>
<blockquote>
<p>没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code> 或 <code>new.target</code>。不能用作构造函数。</p>
</blockquote>
<ul>
<li>
<p>箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this</p>
<p>在箭头函数出现之前，每个新定义的函数都有它自己的 this 值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等）</p>
<blockquote>
<p>由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this---译者注），他们的第一个参数会被忽略。</p>
</blockquote>
</li>
<li>
<p>箭头函数不绑定 Arguments 对象。</p>
</li>
<li>
<p>箭头函数不能用作构造器，和 new 一起用会抛出错误。</p>
</li>
<li>
<p><strong>箭头函数没有 prototype 属性。</strong></p>
</li>
</ul>
<h2 id="fetch-%E5%8F%96%E6%B6%88">fetch 取消</h2>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchController">AbortController</a></p>
</li>
<li>
<p><a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">Abortable fetch</a></p>
</li>
</ul>
<h2 id="symbol">symbol</h2>
<ul>
<li>
<p>Symbol()</p>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</li>
<li>
<p>Symbol.for()</p>
<p>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
</li>
<li>
<p>Symbol.keyFor()</p>
<p>Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</p>
<iframe src="http://es6.ruanyifeng.com/#docs/symbol" width="100%" frameborder="0" height="500px" ></iframe>
</li>
</ul>
<h2 id="js-%E7%BB%A7%E6%89%BF">JS 继承</h2>
<ul>
<li>
<p>原型链：本质是重写原型对象</p>
<ul>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.property = <span class="hljs-literal">true</span>
}

SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.property
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.subProperty = <span class="hljs-literal">false</span>
}

<span class="hljs-comment">// 继承了 SuperType</span>
SubType.prototype = <span class="hljs-keyword">new</span> SuperType()

SubType.prototype.constructor = SubType

SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subProperty
}

<span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">new</span> SubType()
alert(inst.getSuperValue())
</div></code></pre>
</li>
<li>
<p>确定原型和实例关系</p>
<ol>
<li><code>instanceof</code></li>
<li><code>isPrototypeOf()</code></li>
</ol>
</li>
<li>
<p>问题</p>
<ol>
<li>
<p>包含引用类型值的原型</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// 继承了 SuperType</span>
SubType.prototype = <span class="hljs-keyword">new</span> SuperType()
<span class="hljs-keyword">var</span> inst1 = <span class="hljs-keyword">new</span> SubType()
inst1.colors.push(<span class="hljs-string">'black'</span>)
<span class="hljs-built_in">console</span>.log(inst1.colors) <span class="hljs-comment">// 'red', 'blue', 'green', 'black'</span>

<span class="hljs-keyword">var</span> inst2 = <span class="hljs-keyword">new</span> SubType()
<span class="hljs-built_in">console</span>.log(inst2.colors) <span class="hljs-comment">// 'red', 'blue', 'green', 'black'</span>
</div></code></pre>
</li>
<li>
<p>在创建子类型实例的时候，不能向超类型的构造函数中传递参数。</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>借用构造函数</p>
<blockquote>
<p>解决了原型中包含引用类型值所带来的问题</p>
</blockquote>
<blockquote>
<p>子类构造函数中向超类构造函数传递参数</p>
</blockquote>
<ul>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name
  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-comment">// 继承了 SuperType, 同时还传递了参数</span>
  SuperType.call(<span class="hljs-keyword">this</span>, name)
  <span class="hljs-comment">// 实例属性</span>
  <span class="hljs-keyword">this</span>.age = age
}

<span class="hljs-keyword">var</span> inst1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'Nicholas'</span>, <span class="hljs-number">29</span>)
inst1.colors.push(<span class="hljs-string">'black'</span>)
<span class="hljs-built_in">console</span>.log(inst1.colors) <span class="hljs-comment">// 'red', 'blue', 'green', 'black'</span>

<span class="hljs-keyword">var</span> inst2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'Jerry'</span>, <span class="hljs-number">27</span>)
<span class="hljs-built_in">console</span>.log(inst2.colors) <span class="hljs-comment">// 'red', 'blue', 'green'</span>
</div></code></pre>
</li>
<li>
<p>问题</p>
<ol>
<li>方法都在构造函数中定义，函数复用无从谈起。</li>
<li>超类原型中定义的方法，子类不可见。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>组合继承</p>
<blockquote>
<p>将<code>原型链</code> 和 <code>借用构造函数</code> 结合到一起</p>
</blockquote>
<ul>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name
  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}

SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-comment">// 继承 SuperType 实例属性并传递参数</span>
  SuperType.call(<span class="hljs-keyword">this</span>, name)

  <span class="hljs-keyword">this</span>.age = age
}

<span class="hljs-comment">// 继承方法</span>
SubType.prototype = <span class="hljs-keyword">new</span> SuperType()
<span class="hljs-comment">// 修复构造函数</span>
SubType.prototype.constructor = SubType
SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age)
}

<span class="hljs-keyword">var</span> inst1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'Nicholas'</span>, <span class="hljs-number">29</span>)
inst1.colors.push(<span class="hljs-string">'black'</span>)
<span class="hljs-built_in">console</span>.log(inst1.colors) <span class="hljs-comment">// 'red', 'blue', 'green', 'black'</span>
inst1.sayName()
inst1.sayAge()

<span class="hljs-keyword">var</span> inst2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">'Jerry'</span>, <span class="hljs-number">27</span>)
<span class="hljs-built_in">console</span>.log(inst2.colors) <span class="hljs-comment">// 'red', 'blue', 'green'</span>
inst2.sayName()
inst2.sayAge()
</div></code></pre>
</li>
<li>
<p>问题</p>
<ol>
<li>
<p>组合继承无论什么情况下，都会<code>调用两次超类构造函数</code>：</p>
<ul>
<li><code>一次是在创建子类原型的时候</code></li>
<li><code>另一次是在子类构造函数内部调用超类构造函数。</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>原型式继承</p>
<blockquote>
<p><code>Object.create()</code>规范化了原型式继承</p>
</blockquote>
<ul>
<li>
<p><code>Object.create(proto, [propertiesObject])</code></p>
<p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>
<ul>
<li>
<p>proto</p>
<p>新创建对象的原型对象。</p>
</li>
<li>
<p>propertiesObject</p>
<p>可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应 <code>Object.defineProperties()</code> 的第二个参数。</p>
</li>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">'function'</span>) {
  <span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto, propertiesObject</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Object prototype may only be an Object: '</span> + proto)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument."</span>
      )
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> propertiesObject != <span class="hljs-string">'undefined'</span>)
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">"This browser's implementation of Object.create is a shim and doesn't support a second argument."</span>
      )

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}
    F.prototype = proto

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()
  }
}
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>问题</p>
<p>在没有必要兴师动众的创建构造函数，而只是想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。但是，<strong>包含引用类型值的属性始终都会共享相应的值。</strong></p>
</li>
</ul>
</li>
<li>
<p>寄生式继承</p>
<blockquote>
<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象。</p>
</blockquote>
<ul>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>) </span>{
  <span class="hljs-comment">// 通过调用函数创建一个新对象</span>
  <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(original)
  <span class="hljs-comment">// 以某种方式来增强新对象</span>
  clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hi'</span>)
  }
  <span class="hljs-keyword">return</span> clone
}

<span class="hljs-keyword">var</span> person = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nicholas'</span>,
  <span class="hljs-attr">friends</span>: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}
<span class="hljs-keyword">var</span> anotherPerson = createAnother(person)
anotherPerson.sayHi()
</div></code></pre>
</li>
<li>
<p>问题</p>
<ol>
<li>不能做到函数复用而降低效率</li>
</ol>
</li>
</ul>
</li>
<li>
<p>寄生组合式继承</p>
<blockquote>
<p>组合继承无论什么情况下，都会<code>调用两次超类构造函数</code>：</p>
</blockquote>
<blockquote>
<p><code>一次是在创建子类原型的时候</code><br>
<code>另一次是在子类构造函数内部调用超类构造函数。</code></p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// 组合继承🌰</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name
  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}

SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
  SuperType.call(<span class="hljs-keyword">this</span>, name) <span class="hljs-comment">// 第二次调用 SuperType()</span>

  <span class="hljs-keyword">this</span>.age = age
}

SubType.prototype = <span class="hljs-keyword">new</span> SuperType() <span class="hljs-comment">// 第一次调用 SuperType()</span>
SubType.prototype.constructor = SubType
SubType.prototype.sayAge = funciton() {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age)
}
</div></code></pre>
<blockquote>
<p>第一次调用在原型上有两个属性 <code>name</code> 和 <code>colors</code><br>
调用子类构造函数的时候，又会调用  超类构造函数， 又会在新对象上创建实例属性 <code>name</code> 和 <code>colors</code>，于是原型链上的两个同名属性就被屏蔽了</p>
</blockquote>
<ul>
<li>
<p>实现</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) </span>{
  <span class="hljs-keyword">var</span> prototype = <span class="hljs-built_in">Object</span>.create(superType.prototype) <span class="hljs-comment">// 创建对象</span>
  prototype.constructor = subType <span class="hljs-comment">// 增强对象</span>
  subType.protototype = prototype <span class="hljs-comment">// 指定对象</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name
  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
}

SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>{
  SuperType.call(<span class="hljs-keyword">this</span>, name) <span class="hljs-comment">// 第二次调用 SuperType()</span>

  <span class="hljs-keyword">this</span>.age = age
}

inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age)
}
</div></code></pre>
</li>
<li>
<p>引用类型最理想的继承范式</p>
</li>
</ul>
</li>
</ul>
<h2 id="class-%E7%9A%84%E7%BB%A7%E6%89%BF">Class 的继承</h2>
<iframe src="http://es6.ruanyifeng.com/#docs/class-extends#%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C__proto__%E5%B1%9E%E6%80%A7" width="100%" frameborder="0" height="500px" ></iframe>
<h2 id="instanceof">instanceof</h2>
<blockquote>
<p><code>instanceof</code> 运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中的任何位置.<br>
如果左操作数不是对象，则返回 false,如果右操作数不是函数，则抛出 typeError.</p>
</blockquote>
<ul>
<li>
<p>实现原理</p>
<p>instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new_instance_of</span>(<span class="hljs-params">leftVaule, rightVaule</span>) </span>{
  <span class="hljs-keyword">let</span> rightProto = rightVaule.prototype <span class="hljs-comment">// 取右表达式的 prototype 值</span>
  leftVaule = leftVaule.__proto__ <span class="hljs-comment">// 取左表达式的__proto__值</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (leftVaule === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> (leftVaule === rightProto) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    leftVaule = leftVaule.__proto__
  }
}
</div></code></pre>
</li>
<li>
<p>几个有趣的例子</p>
<pre class="hljs"><code><div><span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span> <span class="hljs-comment">// Object 本身是一个函数，由 Function 所创建，所以 `Object.__proto__` 的值是 `Function.prototype`</span>
<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// `Function.prototype` 的 `__proto__` 属性是 `Object.prototype`</span>
<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// Function.__proto__ === Function.prototype, Function.prototype 是由 Object 所创建，所以 Function.prototype.__proto__ === Object.prototype</span>
</div></code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="原型继承的原理图"></p>
</li>
</ul>
<h2 id="typeof">typeof</h2>
<p>typeof 在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object</p>
<p>最好是用 typeof 来判断基本数据类型（包括 symbol）和 function，避免对 null 的判断。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// "undefined"</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// "boolean"</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{} <span class="hljs-comment">// "function"</span>
<span class="hljs-keyword">typeof</span> {} <span class="hljs-comment">// "object"</span>
<span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// "object"</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// "object"</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">// "object"</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">// "object"</span>
</div></code></pre>
<p><strong>还有一个不错的判断类型的方法，就是 Object.prototype.toString</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>) <span class="hljs-comment">// "[object Number]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'hi'</span>) <span class="hljs-comment">// "[object String]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call({ <span class="hljs-attr">a</span>: <span class="hljs-string">'hi'</span> }) <span class="hljs-comment">// "[object Object]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>]) <span class="hljs-comment">// "[object Array]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// "[object Boolean]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}) <span class="hljs-comment">// "[object Function]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// "[object Null]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// "[object Undefined]"</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// "[object Symbol]"</span>
</div></code></pre>
<pre class="hljs"><code><div>
<span class="hljs-keyword">let</span> class2Type = {}
[<span class="hljs-string">'Array'</span>, <span class="hljs-string">'Date'</span>,<span class="hljs-string">'RegExp'</span>, <span class="hljs-string">'Error'</span>, <span class="hljs-string">'Object'</span>].forEach(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> class2Type[<span class="hljs-string">`[object <span class="hljs-subst">${type}</span>]`</span>] = type.toLowerCase())

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span>(obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> ? class2Type[<span class="hljs-built_in">Object</span>.prototype.toString.call(obj)] || <span class="hljs-string">'object'</span> : <span class="hljs-keyword">typeof</span> obj
}
</div></code></pre>
<h2 id="typeof-%E5%92%8C-instanceof%E7%9A%84%E5%8C%BA%E5%88%AB"><a href="https://segmentfault.com/a/1190000000730982">typeof 和 instanceOf的区别</a></h2>
<blockquote>
<p>只有字面量形式的 <code>string</code>、 <code>number</code>、 <code>boolean</code>、 <code>undefined</code>、<code>function</code> 才能分辨出来，其他都为 <code>object</code></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">Class</th>
<th style="text-align:left">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&quot;foo&quot;</td>
<td style="text-align:left">String</td>
<td style="text-align:left">string</td>
</tr>
<tr>
<td style="text-align:left">new String(&quot;foo&quot;)</td>
<td style="text-align:left">String</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">1.2</td>
<td style="text-align:left">Number</td>
<td style="text-align:left">number</td>
</tr>
<tr>
<td style="text-align:left">new Number(1.2)</td>
<td style="text-align:left">Number</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">new Boolean(true)</td>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">new Date()</td>
<td style="text-align:left">Date</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">new Error()</td>
<td style="text-align:left">Error</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">[1,2,3]</td>
<td style="text-align:left">Array</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">new Array(1, 2, 3)</td>
<td style="text-align:left">Array</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">new Function(&quot;&quot;)</td>
<td style="text-align:left">Function</td>
<td style="text-align:left">function</td>
</tr>
<tr>
<td style="text-align:left">/abc/g</td>
<td style="text-align:left">RegExp</td>
<td style="text-align:left">object (function in Nitro/V8)</td>
</tr>
<tr>
<td style="text-align:left">new RegExp(&quot;meow&quot;)</td>
<td style="text-align:left">RegExp</td>
<td style="text-align:left">object (function in Nitro/V8)</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">new Object()</td>
<td style="text-align:left">Object</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">Null</td>
<td style="text-align:left">object</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">Undefined</td>
<td style="text-align:left">undefined</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Class 一列表示对象的内部属性 [[Class]] 的值。<br>
为了获取对象的 [[Class]]，我们需要使用定义在 Object.prototype 上的方法 toString。</p>
</blockquote>
<h2 id="%E6%95%B0%E5%AD%97%E5%8D%83%E5%88%86%E4%BD%8D%E5%A4%84%E7%90%86%EF%BC%8C%E6%AD%A3%E5%88%99%E5%92%8C%E9%9D%9E%E6%AD%A3%E5%88%99%E9%83%BD%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%BD%8D%E5%8A%A0%E9%80%97%E5%8F%B7">数字千分位处理，正则和非正则都要实现(千位加逗号)</h2>
<ul>
<li>
<p><code>numObj.toLocaleString([locales [, options]])</code></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 方法一</span>
<span class="hljs-keyword">var</span> num = <span class="hljs-number">234982347.73</span>
<span class="hljs-built_in">console</span>.log(num.toLocaleString())

<span class="hljs-comment">// 方法二</span>
<span class="hljs-keyword">var</span> num = <span class="hljs-number">234982347.73</span>
num.toString().replace(<span class="hljs-regexp">/^\d+/g</span>, m =&gt; m.replace(<span class="hljs-regexp">/(\d{1,3})(?=(?:\d{3})+$)/g</span>, <span class="hljs-string">'$1,'</span>))
</div></code></pre>
</li>
</ul>
<h2 id="%E6%AD%A3%E5%88%99"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则</a></h2>
<p><img src="./RegExp.png" alt="正则表达式中特殊字符的含义"></p>
<ul>
<li>
<p>标识符：</p>
<ul>
<li>g: 全局</li>
<li>i: 忽略大小写</li>
<li>m: 多行模式， 在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
</li>
<li>
<p>元字符：</p>
<ul>
<li><code>([{\^$|}?*+.])</code></li>
<li>所有的元字符都必须经过转义</li>
</ul>
</li>
<li>
<p>使用 <code>RegExp</code> 构造函数</p>
<ul>
<li>由于 <code>RegExp</code> 构造函数的模式参数是个字符串，所以在某些情况下要对字符串进行双重转义
<table>
<thead>
<tr>
<th style="text-align:left">字面量模式</th>
<th style="text-align:left">等价的字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>/\[bc\]at/</code></td>
<td style="text-align:left"><code>\\[bc\\]at</code></td>
</tr>
<tr>
<td style="text-align:left"><code>/\.at/</code></td>
<td style="text-align:left"><code>\\.at</code></td>
</tr>
<tr>
<td style="text-align:left"><code>/name\/age/</code></td>
<td style="text-align:left"><code>name\\/age</code></td>
</tr>
<tr>
<td style="text-align:left"><code>/\d.\d{1,2}/</code></td>
<td style="text-align:left"><code>\\d.\\d{1,2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>/\w\\hello\\123/</code></td>
<td style="text-align:left"><code>\\w\\\\hello\\\\123</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>ES5 明确规定， 使用正则表达式字面量必须像直接调用 <code>RegExp</code> 构造函数一样，每次都创建新的 <code>RegExp</code> 实例。</p>
</li>
<li>
<p>实例属性</p>
<ul>
<li>global</li>
<li>ignoreCase</li>
<li>multiline</li>
<li>source: 正则表达式的字符串表示，按照<strong>字面量形式</strong>而非传入构造函数的字符串模式</li>
<li>lastIndex: 开始搜索下一个匹配项的字符位置，起始 0</li>
</ul>
</li>
<li>
<p>实例方法</p>
<ul>
<li>exec(): 专门为捕获组而设计，返回包含第一个匹配项信息的数组， 没有匹配项返回 null
<ul>
<li>返回数组属性
<ul>
<li>第一项是与整个模式匹配的字符串</li>
<li>其他项是与模式中的捕获组匹配的字符串</li>
<li>index: 匹配项在字符串中的位置</li>
<li>input: 应用正则表达式的字符串</li>
</ul>
</li>
<li>模式中设置了 <code>g</code> 标志,每次也只返回一个匹配项
<ul>
<li>同一个字符串多次调用 <code>exec()</code>,每次调用都会在字符串中继续查找新的匹配项</li>
</ul>
</li>
</ul>
</li>
<li>test(): 是否匹配</li>
<li>toLocaleString(): 返回正则表达式字面量</li>
<li>toString(): 返回正则表达式字面量</li>
</ul>
</li>
<li>
<p>构造函数属性</p>
<table>
<thead>
<tr>
<th style="text-align:left">长属性名</th>
<th style="text-align:left">短属性名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">input</td>
<td style="text-align:left">$_</td>
<td style="text-align:left">最近一次要匹配的字符串</td>
</tr>
<tr>
<td style="text-align:left">lastMatch</td>
<td style="text-align:left">$&amp;</td>
<td style="text-align:left">最近一次匹配项</td>
</tr>
<tr>
<td style="text-align:left">lastParen</td>
<td style="text-align:left">$+</td>
<td style="text-align:left">最近一次匹配的捕获组</td>
</tr>
<tr>
<td style="text-align:left">leftContext</td>
<td style="text-align:left">$`</td>
<td style="text-align:left">input 字符串中 lastMatch 之前的文本</td>
</tr>
<tr>
<td style="text-align:left">rightContext</td>
<td style="text-align:left">$'</td>
<td style="text-align:left">input字符串中lastMatch之后的文本</td>
</tr>
<tr>
<td style="text-align:left">multiline</td>
<td style="text-align:left">$*</td>
<td style="text-align:left">布尔值，是否所有的表达式都使用多行模式</td>
</tr>
<tr>
<td style="text-align:left">$1,$2,...,$9</td>
<td style="text-align:left">存储第一到第九个捕获组，调用 exec()或 test()时，这些属性自动填充</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则 test, match, exec</a></p>
<ul>
<li>test\exec 是正则的实例方法， match 是字符串的方法</li>
<li>test 匹配与否，返回Boolean</li>
<li>match\exec 捕获组， 如果匹配，返回数组，未匹配返回null
<ul>
<li>返回数组第一项为正则匹配的整个字符串，后面为括号对应的捕获组，index是整个匹配从零开始的索引，Input 为被解析的原始字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-bind-%E5%87%BD%E6%95%B0">实现一个 bind 函数 *</h2>
<p>bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p>
<p><code>function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>
<ul>
<li>
<p>thisArg</p>
<p>调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。<strong>如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。</strong></p>
</li>
<li>
<p>arg1, arg2, ...</p>
<p>当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Function</span>.prototype.bind) {
  <span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">oThis</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)
    }

    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>),
      functionToBind = <span class="hljs-keyword">this</span>,
      functionBound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
        <span class="hljs-comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span>
        <span class="hljs-keyword">return</span> functionToBind.apply(
          <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> functionBound ? <span class="hljs-keyword">this</span> : oThis,
          <span class="hljs-comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span>
          args.concat(bindArgs)
        )
      }

    <span class="hljs-comment">// 我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</span>

    <span class="hljs-comment">// 维护原型关系(原型链继承)</span>
    <span class="hljs-keyword">var</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.prototype) {
      fNOP.prototype = <span class="hljs-keyword">this</span>.prototype
    }

    functionBound.prototype = <span class="hljs-keyword">new</span> fNOP()

    <span class="hljs-comment">// functionbound.prototype = Object.create(this.prototype);</span>

    <span class="hljs-keyword">return</span> functionBound
  }
}
</div></code></pre>
<h2 id="%E7%BC%96%E7%A8%8B">编程</h2>
<ul>
<li>实现一个flatten方法。</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">input</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(input)){
      <span class="hljs-keyword">var</span> output = []
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_flatten</span> (<span class="hljs-params">input</span>) </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++){
          <span class="hljs-keyword">var</span> value = input[i]
          <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(value)) {
            _flatten(value)
          }
          <span class="hljs-keyword">else</span>{
            output.push(value)
          }
        }
      }
      _flatten(input)
      <span class="hljs-keyword">return</span> output
    }<span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> input;
    }
  }
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">input</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(input) ? input.toString().split(<span class="hljs-string">','</span>) : input
  }
</div></code></pre>
<ul>
<li>将一个json数据的所有key从下划线改为驼峰</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> testData = {
    <span class="hljs-attr">a_bbb</span>: <span class="hljs-number">123</span>,
    <span class="hljs-attr">a_g</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
    <span class="hljs-attr">a_d</span>: {
        <span class="hljs-attr">s</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">s_d</span>: <span class="hljs-number">3</span>
    },
    <span class="hljs-attr">a_f</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, {
        <span class="hljs-attr">a_g</span>: <span class="hljs-number">5</span>
    }],
    <span class="hljs-attr">a_d_s</span>: <span class="hljs-number">1</span>
}

<span class="hljs-comment">/**
 * 将一个json数据的所有key从下划线改为驼峰
 * 
 * @param {object | array} value 待处理对象或数组
 * @returns {object | array} 处理后的对象或数组
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapKeysToCamelCase</span>(<span class="hljs-params">data</span>) </span>{
    
    <span class="hljs-comment">/**
     * 如果是基本常量return
     */</span>
    <span class="hljs-keyword">if</span>(isBaseType(data)) {
        <span class="hljs-keyword">return</span> data
    }

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(data)) {
        <span class="hljs-keyword">return</span> data.map(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> isBaseType(key)? key: mapKeysToCamelCase(key)
        })
    }
    
    <span class="hljs-keyword">let</span> obj={};

    <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> _key = strToCamelCase(key);
        obj[_key] = mapKeysToCamelCase(data[key])
    })
    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-keyword">const</span> isBaseType= (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> baseTypes = [<span class="hljs-string">"Number"</span>, <span class="hljs-string">"String"</span>,<span class="hljs-string">"Boolean"</span>,<span class="hljs-string">"Null"</span>,<span class="hljs-string">"Undefined"</span>].map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`[object <span class="hljs-subst">${item}</span>]`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> tp = <span class="hljs-built_in">Object</span>.prototype.toString.call(val)
      <span class="hljs-keyword">return</span> baseTypes.includes(tp);
    }
})()

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strToCamelCase</span>(<span class="hljs-params">key</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-string">''</span>+key</span>).<span class="hljs-params">replace</span>(<span class="hljs-params"><span class="hljs-regexp">/(_.{1})/g</span>, (val</span>) =&gt;</span> val.slice(<span class="hljs-number">1</span>).toUpperCase());
}

<span class="hljs-built_in">console</span>.log(mapKeysToCamelCase(testData))
</div></code></pre>
<ul>
<li>JS中判断字符串中出现次数最多的字符及出现的次数</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxN</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-comment">// const obj = (''+str).split('').reduce((accu, cur, index) =&gt; {</span>
    <span class="hljs-comment">// accu[cur] = (accu[cur] || 0) + 1;</span>
    <span class="hljs-comment">// return accu</span>
    <span class="hljs-comment">// }, </span>
    <span class="hljs-comment">// {}</span>
    <span class="hljs-comment">// );</span>


    <span class="hljs-keyword">let</span> obj = {};
    (<span class="hljs-string">''</span>+str).replace(<span class="hljs-regexp">/(\w{1})/g</span>, letter =&gt; {
      obj[letter]?obj[letter] += <span class="hljs-number">1</span>: obj[letter] = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> letter;
    })

    <span class="hljs-keyword">let</span> letter = <span class="hljs-string">''</span>,
        max = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> _letter <span class="hljs-keyword">in</span> obj) {
      <span class="hljs-keyword">if</span>(obj[_letter] &gt; max) {
        max = obj[_letter];
        letter = _letter
      }
    }

    <span class="hljs-keyword">return</span> {letter, max}
  }

  <span class="hljs-keyword">const</span> str = <span class="hljs-string">'qweqrtyuiqqqwrtyudfgerqtywer'</span>;
  <span class="hljs-built_in">console</span>.log(maxN(str))
</div></code></pre>
<ul>
<li>请编写一个 JavaScript 函数 parseQueryString ，他的用途是把URL参数解析为一个对象</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseQueryString</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">let</span> result = {};
    <span class="hljs-keyword">let</span> arr = url.split(<span class="hljs-string">'?'</span>);
    <span class="hljs-keyword">if</span>(arr.length &lt;= <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">else</span> {
      arr = arr[<span class="hljs-number">1</span>].split(<span class="hljs-string">'#'</span>);
      arr = arr[<span class="hljs-number">0</span>].split(<span class="hljs-string">'&amp;'</span>);
      arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> [key, value] = item.split(<span class="hljs-string">'='</span>);
        result[key] = value;
      })
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">var</span> url = <span class="hljs-string">"http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2#location"</span>;

  <span class="hljs-built_in">console</span>.log(parseQueryString(url))
</div></code></pre>
<ul>
<li>在IE6.0下面是不支持 <code>position：fixed</code> 的，请写一个JS使用固定在页面的右下角。</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.tit</span> {
          <span class="hljs-attribute">position</span>: absolute;
          <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
          <span class="hljs-attribute">background</span>: red;
          <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
          <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
        }
      </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- &lt;script&gt;
        window.onscroll = window.onresize = window.onload = function() {
          const box = document.getElementById('box')
          const scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          box.style.left = document.documentElement.clientWidth - box.offsetWidth + 'px'
          box.style.top = document.documentElement.clientHeight + scrollTop - box.offsetHeight + 'px'
        }
      &lt;/script&gt; --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<ul>
<li>请实现，鼠标移到页面中的任意标签，显示出这个标签的基本矩形轮廓。</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseOverShowBorder</span>(<span class="hljs-params">container</span>) </span>{
    <span class="hljs-keyword">const</span> children = container.childNodes
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
      <span class="hljs-keyword">const</span> child = children[i]

      <span class="hljs-keyword">if</span> (child.nodeType === <span class="hljs-number">1</span>) {
        child.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">this</span>.style.border = <span class="hljs-string">'1px solid #ccc'</span>
        }

        child.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">this</span>.style.border = <span class="hljs-string">''</span>
        }

        mouseOverShowBorder(child)
      }
    }
  }

  mouseOverShowBorder(<span class="hljs-built_in">document</span>.body)
</div></code></pre>
<ul>
<li>
<p>排序算法</p>
<ul>
<li>
<p>冒泡排序</p>
<pre class="hljs"><code><div>  <span class="hljs-comment">/**
    * 从后往前比较
    */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">if</span>(arr === <span class="hljs-literal">null</span> || arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length - <span class="hljs-number">1</span>; i &lt; len; i++) {
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = arr.length - <span class="hljs-number">1</span>; j &gt; i; j--) {
        <span class="hljs-keyword">if</span>(arr[j] &lt; arr[j<span class="hljs-number">-1</span>]) {
          swap(arr, j, j<span class="hljs-number">-1</span>);
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>{
      <span class="hljs-comment">// let temp = arr[i];</span>
      <span class="hljs-comment">// arr[i] = arr[j];</span>
      <span class="hljs-comment">// arr[j] = temp;</span>
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }

    <span class="hljs-keyword">return</span> arr;
  }
</div></code></pre>
</li>
<li>
<p>选择排序</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length - <span class="hljs-number">1</span>; i &lt; len; i++) {
      <span class="hljs-keyword">let</span> minIndex = i
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>, len = arr.length; j &lt; len; j++) {
        <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) {
          minIndex = j
        }
      }

      <span class="hljs-keyword">if</span> (minIndex !== i) {
        swap(arr, i, minIndex)
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>{
      ;[arr[i], arr[j]] = [arr[j], arr[i]]
    }
    <span class="hljs-keyword">return</span> arr
  }
</div></code></pre>
</li>
<li>
<p>插入排序</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">if</span> (arr === <span class="hljs-literal">null</span> || arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, len = arr.length; i &lt; len; i++) {
      <span class="hljs-comment">// 假设第一个数是正确的</span>
      <span class="hljs-keyword">let</span> j = i,
        target = arr[i] <span class="hljs-comment">//待插入的</span>

      <span class="hljs-comment">//后移</span>
      <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; target &lt; arr[j - <span class="hljs-number">1</span>]) {
        arr[j] = arr[j - <span class="hljs-number">1</span>]
        j--
      }

      <span class="hljs-comment">//插入</span>
      arr[j] = target
    }

    <span class="hljs-keyword">return</span> arr
  }
</div></code></pre>
</li>
<li>
<p>数组去重</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> arr.indexOf(item) === index);
  }
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> obj = {};
    <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-keyword">if</span>(obj[item]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      obj[item] = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    })
  }
</div></code></pre>
</li>
<li>
<p>字符串去重</p>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(str)].join(<span class="hljs-string">''</span>)
  }
</div></code></pre>
<ul>
<li>
<p>输入 <code>携程C2t0r1i8p2020校招</code>, 输出 <code>2018Ctrip</code></p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStr</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">let</span> nums = str.match(<span class="hljs-regexp">/\d/g</span>).join(<span class="hljs-string">''</span>);
    <span class="hljs-keyword">let</span> words = str.match(<span class="hljs-regexp">/[a-zA-Z]/g</span>).join(<span class="hljs-string">''</span>);

    <span class="hljs-keyword">return</span> uniqueStr(nums) + words;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqueStr</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">const</span> arr = str.split(<span class="hljs-string">''</span>);
    <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> arr.indexOf(item) === index).join(<span class="hljs-string">''</span>);
  }
</div></code></pre>
</li>
<li>
<p>对一维数组，根据 type 类型分组成二维数组</p>
<pre class="hljs"><code><div>  <span class="hljs-comment">// var input = [null, 2, "test", undefined, {</span>
  <span class="hljs-comment">//        "type": "product",</span>
  <span class="hljs-comment">//        "content": "product1"</span>
  <span class="hljs-comment">//      }, {</span>
  <span class="hljs-comment">//        "type": "product",</span>
  <span class="hljs-comment">//        "content": "product2"</span>
  <span class="hljs-comment">//      }, {</span>
  <span class="hljs-comment">//        "type": "tag",</span>
  <span class="hljs-comment">//        "content": "tag1"</span>
  <span class="hljs-comment">//      }, {</span>
  <span class="hljs-comment">//        "type": "product",</span>
  <span class="hljs-comment">//        "content": "product3"</span>
  <span class="hljs-comment">//      }, {</span>
  <span class="hljs-comment">//        "type": "tag",</span>
  <span class="hljs-comment">//        "content": "tag2"</span>
  <span class="hljs-comment">//      }];</span>

  <span class="hljs-comment">// output = [{"type":"product","contents":["product1","product2","product3"]},{"type":"tag","contents":["tag1","tag2"]}]</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupList</span>(<span class="hljs-params">arr</span>) </span>{
      <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(arr) || arr.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> []
      }

      <span class="hljs-keyword">const</span> validItems = getValidItems(arr);
      <span class="hljs-keyword">const</span> result = {}

      validItems.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
        result[item.type] ? result[item.type].push(item) : result[item.type] = [item]
        <span class="hljs-comment">// if(result.hasOwnProperty(item.type)) {</span>
        <span class="hljs-comment">//  result[item.type].push(item)</span>
        <span class="hljs-comment">// } else {</span>
        <span class="hljs-comment">//  result[item.type] = [];</span>
        <span class="hljs-comment">//  result[item.type].push(item)</span>
        <span class="hljs-comment">// }</span>
      })

      <span class="hljs-keyword">return</span> resultFormat(result);
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValidItems</span>(<span class="hljs-params">arr</span>) </span>{
      <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> isPureObject(item) &amp;&amp; item.type &amp;&amp; item.content)
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPureObject</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>) === <span class="hljs-string">'Object'</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resultFormat</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).map(<span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> {type, <span class="hljs-attr">contents</span>: obj[type]}
      })
    }
</div></code></pre>
</li>
<li>
<p>计算目录 <code>/a/b/c/d/e.js</code> 和 <code>/a/b/f/g.js</code> 的相对目录</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caculateRoute</span>(<span class="hljs-params">path1, path2</span>) </span>{
    <span class="hljs-keyword">let</span> pathArr1 = path1.split(<span class="hljs-string">'/'</span>),
        pathArr2 = path2.split(<span class="hljs-string">'/'</span>),

        routeArr = [],
        fileArr = [],
        diff = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>, len = pathArr1.length; i&lt;len; i++) {
      <span class="hljs-keyword">if</span>(pathArr1[i] !== pathArr2[i] ||  diff) {
        <span class="hljs-keyword">if</span>(pathArr1[i]){
          routeArr.push(<span class="hljs-string">'..'</span>);
        }
        <span class="hljs-keyword">if</span>(pathArr2[i]) {
          fileArr.push(pathArr2[i]);
        }
        diff = <span class="hljs-literal">true</span>
      } <span class="hljs-keyword">else</span> {
        diff = <span class="hljs-literal">false</span>
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${routeArr.join(<span class="hljs-string">'/'</span>)}</span>/<span class="hljs-subst">${fileArr.join(<span class="hljs-string">'/'</span>)}</span>`</span>
  }

  <span class="hljs-keyword">let</span> path = caculateRoute(<span class="hljs-string">'/a/b/c/d/e.js'</span>, <span class="hljs-string">'/a/b/f/g.js'</span>);
</div></code></pre>
</li>
<li>
<p>使用promise 4秒后打印’A’，然后经过3秒打印’B’，再经过2秒打印’C’，再经过一秒打印’D’。</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'A'</span>);
      resolve();
    }, <span class="hljs-number">4000</span>);
  })

  promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'B'</span>);
        resolve();
      }, <span class="hljs-number">3000</span>);
    })
  })
  .then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'C'</span>);
        resolve();
      }, <span class="hljs-number">2000</span>);
    })
  })
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'D'</span>);
        resolve();
      }, <span class="hljs-number">1000</span>);
    })
  })
</div></code></pre>
</li>
<li>
<p>实现一个数组中删除一个子数组的函数，要求函数中不return返回新的数组。</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeSubArray</span>(<span class="hljs-params">main, sub</span>) </span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;main.length; i++) {
      <span class="hljs-keyword">if</span>(sub.includes(main[i])) {
        main.splice(i, <span class="hljs-number">1</span>);
        i--;
      }
    }
  }
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="javascript-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><a href="https://juejin.im/entry/5a28ec86f265da43163cf720">JavaScript 中的对象拷贝</a></h2>
<ul>
<li>
<p>浅拷贝</p>
<ul>
<li>Object.assign()、扩展运算符(...)
<ol>
<li>复制对象的可枚举属性</li>
<li>可以拷贝方法，和循环引用</li>
<li>复制的嵌套属性是引用，共享</li>
</ol>
</li>
</ul>
</li>
<li>
<p>深拷贝</p>
<ul>
<li>JSON.parse(JSON.stringify(obj))<br>
原型改变，不能复制对象方法，不能复制循环引用</li>
<li>递归遍历属性，复制属性 Object.getOwnPropertyDescriptor</li>
</ul>
</li>
</ul>
<h2 id="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-new-%E6%93%8D%E4%BD%9C%E7%AC%A6"><a href="https://www.cnblogs.com/onepixel/p/5043523.html">深入理解 new 操作符</a></h2>
<pre class="hljs"><code><div>  <span class="hljs-keyword">new</span> Animal() {
    <span class="hljs-keyword">const</span> obj = {};
    obj.__proto__ = Animal.prototype;

    <span class="hljs-keyword">const</span> result = Animal.apply(obj, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">return</span> result!==<span class="hljs-literal">null</span> &amp;&amp; result : obj; <span class="hljs-comment">// 忽略 null</span>

  }
</div></code></pre>
<h2 id="forin%E8%BF%AD%E4%BB%A3%E5%92%8Cforof%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">for...in迭代和for...of有什么区别</h2>
<ul>
<li>
<p>for...in</p>
<blockquote>
<p>以任意顺序遍历对象的可枚举属性 （enumerable properties），包括对象从其构造函数原型中继承的属性。</p>
</blockquote>
</li>
<li>
<p>for...of</p>
<blockquote>
<p>遍历可迭代对象（iterable object, 定义了 Symbol.iterator 方法） 定义的可迭代的数据 ，比如遍历 Array，Map，Set，String，TypedArray，arguments 等对象的数据。</p>
</blockquote>
</li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/wangjun5159/article/details/51479569">for...in 和 for...of 区别</a></li>
<li><a href="https://www.jianshu.com/p/c43f418d6bf0">for in 和for of的区别</a></li>
</ul>
<h2 id="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-babel-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><a href="https://www.jianshu.com/p/e9b94b2d52e2">深入理解 Babel 原理及其使用</a></h2>
<h2 id="%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AF%A6%E7%BB%86%E5%9B%BE%E8%A7%A3"><a href="https://www.jianshu.com/p/a6d37c77e8db">前端基础进阶（二）：执行上下文详细图解</a></h2>
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><a href="https://segmentfault.com/a/1190000009522006">什么是作用域和执行上下文</a></h3>
<h3 id="javascript-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC"><a href="https://blog.csdn.net/wy818/article/details/49247675">Javascript 函数声明的优先级高于变量声明的优先级，但不会覆盖变量赋值</a></h3>
<h2 id="set-%E5%92%8C-map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Set 和 Map 数据结构</h2>
<iframe src="http://es6.ruanyifeng.com/#docs/set-map" width="100%" frameborder="0" height="500px" ></iframe>
<h2 id="%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">异步解决方案</h2>
<h3 id="promise">Promise</h3>
<ul>
<li><a href="https://github.com/xieranmaya/blog/issues/3">【剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类】</a></li>
</ul>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25178630">深入 Promise(一)——Promise 实现详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25198178">深入 Promise(二)——进击的 Promise</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25199781">深入 Promise(三)——命名 Promise</a></li>
</ul>
<ul>
<li>
<p><a href="https://github.com/xieranmaya/Promise3/blob/master/Promise3.js">实现</a></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
  self.status = <span class="hljs-string">'pending'</span>
  self.value = <span class="hljs-literal">undefined</span>
  self.onResolveCallback = []
  self.onRejectCallback = []

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
      <span class="hljs-keyword">return</span> value.then(resolve, reject)
    }
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">'pending'</span>) {
        self.status = <span class="hljs-string">'fulfilled'</span>
        self.value = value
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onResolveCallback.length; i++) {
          self.onResolveCallback[i](value)
        }
      }
    })
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">'pending'</span>) {
        self.status = <span class="hljs-string">'rejected'</span>
        self.value = reason
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.onRejectCallback.length; i++) {
          self.onRejectCallback[i](reason)
        }
      }
    })
  }

  <span class="hljs-keyword">try</span> {
    executor(resolve, reject)
  } <span class="hljs-keyword">catch</span> (e) {
    reject(e)
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>{
  <span class="hljs-keyword">var</span> then
  <span class="hljs-keyword">var</span> thenCalledOrThrow = <span class="hljs-literal">false</span>

  <span class="hljs-keyword">if</span> (promise2 === x) {
    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Chaining cycle detected for promise!'</span>))
  }

  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) {
    <span class="hljs-keyword">if</span> (x.status === <span class="hljs-string">'pending'</span>) {
      x.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        resolvePromise(promise2, value, resolve, reject)
      }, reject)
    } <span class="hljs-keyword">else</span> {
      x.then(resolve, reject)
    }
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>)) {
    <span class="hljs-keyword">try</span> {
      then = x.then
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) {
        then.call(
          x,
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rs</span>(<span class="hljs-params">y</span>) </span>{
            <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>
            thenCalledOrThrow = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject)
          },
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rj</span>(<span class="hljs-params">r</span>) </span>{
            <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>
            thenCalledOrThrow = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">return</span> reject(r)
          }
        )
      } <span class="hljs-keyword">else</span> {
        resolve(x)
      }
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span>
      thenCalledOrThrow = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">return</span> reject(e)
    }
  } <span class="hljs-keyword">else</span> {
    resolve(x)
  }
}

<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
  <span class="hljs-keyword">var</span> promise2

  onResolved =
    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">'function'</span>
      ? onResolved
      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
          <span class="hljs-keyword">return</span> value
        }
  onRejected =
    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span>
      ? onRejected
      : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
          <span class="hljs-keyword">throw</span> reason
        }

  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">'fulfilled'</span>) {
    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> x = onResolved(self.value)
          resolvePromise(promise2, x, resolve, reject)
        } <span class="hljs-keyword">catch</span> (e) {
          reject(e)
        }
      })
    }))
  }

  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">'rejected'</span>) {
    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> x = onReject(self.value)
          resolvePromise(promise2, x, resolve, reject)
        } <span class="hljs-keyword">catch</span> (e) {
          reject(e)
        }
      })
    }))
  }

  <span class="hljs-keyword">if</span> (self.status === <span class="hljs-string">'pending'</span>) {
    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
      self.onResolvedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> x = onResolved(value)
          resolvePromise(promise2, x, resolve, reject)
        } <span class="hljs-keyword">catch</span> (e) {
          reject(e)
        }
      })

      self.onRejectedCallback.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> x = onReject(reason)
          resolvePromise(promise2, x, resolve, reject)
        } <span class="hljs-keyword">catch</span> (e) {
          reject(e)
        }
      })
    }))
  }
}

<span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onReject</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onReject)
}

<span class="hljs-built_in">Promise</span>.deferred = <span class="hljs-built_in">Promise</span>.defer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> dfd = {}
  dfd.promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    dfd.resolve = resolve
    dfd.reject = reject
  })
  <span class="hljs-keyword">return</span> dfd
}
</div></code></pre>
</li>
</ul>
<h3 id="generator">generator</h3>
<iframe src="http://es6.ruanyifeng.com/#docs/generator" width="100%" frameborder="0" height="500px" ></iframe>
<h3 id="asyncawait">async/await</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">const</span> gen = genF();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>) </span>{
      <span class="hljs-keyword">let</span> next;
      <span class="hljs-keyword">try</span>{
        next = nextF();
      }<span class="hljs-keyword">catch</span>(err) {
        <span class="hljs-keyword">return</span> reject(err);
      }
      <span class="hljs-keyword">if</span>(next.done) {
        <span class="hljs-keyword">return</span> resolve(next.value);
      }

      <span class="hljs-built_in">Promise</span>.resolve(next.value).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(v); });
      }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
        step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.throw(err); });
      });
    }

    step(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> gen.next(<span class="hljs-literal">undefined</span>); });
  })
}

</div></code></pre>
<iframe src="http://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" width="100%" frameborder="0" height="500px" ></iframe>
<h3 id="promise-%E5%92%8C-async-%E5%8C%BA%E5%88%AB">promise 和 async 区别</h3>
<p>async 和 promise 都不会阻塞执行，await 只会对 async 函数内 await 之后的代码产生阻塞。</p>
<p>async 异常捕获用 try...catch, promise 直接用 catch(), try...catch 无法捕获 promise 异常。</p>
<p>async...await 是 Generator 函数语法糖， co 模块实现是通过 Promise 包装的。</p>
<h2 id="%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81">防抖与节流</h2>
<ul>
<li>
<p>防抖</p>
<p>将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</p>
<p><a href="https://github.com/lodash/lodash/blob/master/debounce.js">lodash debounce</a></p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, interval</span>) </span>{
    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      clearTimeout(timeout);

      timeout = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      }, interval);
    }
  }
</div></code></pre>
</li>
<li>
<p>节流</p>
<p>每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。</p>
<p><a href="https://github.com/lodash/lodash/blob/master/throttle.js">lodash throttle</a></p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, interval</span>) </span>{
    <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span>(!canRun) <span class="hljs-keyword">return</span> 

      canRun = <span class="hljs-literal">false</span>;

      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        canRun = <span class="hljs-literal">true</span>;
      }, interval);
    }
  }
</div></code></pre>
</li>
</ul>
<h2 id="this-%E6%8C%87%E5%90%91">this 指向</h2>
<ul>
<li><a href="https://www.cnblogs.com/pssp/p/5216085.html">彻底理解js中this的指向，不必硬背。</a></li>
<li><a href="https://juejin.im/post/5c049e6de51d45471745eb98">彻底理解JavaScript中的this</a></li>
</ul>
<h2 id="import-%E5%92%8C-require-%E7%9A%84%E5%8C%BA%E5%88%AB">import 和 require 的区别</h2>
<ul>
<li>
<p>import 是关键字， 而 require 是个局部变量</p>
<p>使用 require 的时候，其实会将 module 的代码进行包装，变成如下样子的代码：</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exports, require, module, __filename, __dirname</span>) </span>{
    <span class="hljs-keyword">const</span> m = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">module</span>.exports.m = m;
  }
</div></code></pre>
</li>
<li>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// CommonJS模块</span>
<span class="hljs-keyword">let</span> { stat, exists, readFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">let</span> stat = _fs.stat
<span class="hljs-keyword">let</span> exists = _fs.exists
<span class="hljs-keyword">let</span> readfile = _fs.readfile
</div></code></pre>
<blockquote>
<p>上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
</blockquote>
<blockquote>
<p>ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入。</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// ES6模块</span>
<span class="hljs-keyword">import</span> { stat, exists, readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
</div></code></pre>
<blockquote>
<p>上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
</blockquote>
</li>
<li>
<p>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}
=&gt;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{}
<span class="hljs-keyword">export</span> { a <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> }

================华丽分割线=====================

<span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>;
=&gt;
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> a } <span class="hljs-keyword">from</span> <span class="hljs-string">'./d'</span>
</div></code></pre>
</li>
</ul>
<ol>
<li>CommonJS 还是 ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象；</li>
</ol>
<ul>
<li>
<p>require</p>
<p>理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用</p>
<pre class="hljs"><code><div><span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)() <span class="hljs-comment">// a模块是一个函数，立即执行a模块函数</span>
<span class="hljs-keyword">var</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>).data <span class="hljs-comment">// a模块导出的是一个对象</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment">// a模块导出的是一个数组</span>
</div></code></pre>
</li>
</ul>
<h2 id="es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82"><a href="http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82">ES6 模块与 CommonJS 模块的差异</a></h2>
<iframe src="http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" width="100%" frameborder="0" height="500px" ></iframe>
<h2 id="script%08-%E5%B1%9E%E6%80%A7-defer-%E5%92%8C-async-%E5%8C%BA%E5%88%AB">script 属性 defer 和 async 区别</h2>
<p>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>
<p>“每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。”--------------HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但实际情况下，延迟脚本不一定按照先后顺序执行！！！</p>
<p><img src="https://segmentfault.com/img/bVWhRl?w=801&amp;h=814" alt=""></p>
<h1 id="%E6%B5%8F%E8%A7%88%E5%99%A8">浏览器</h1>
<h2 id="chrome%E6%98%BE%E7%A4%BA12px%E4%BB%A5%E4%B8%8B%E5%AD%97%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><a href="https://blog.csdn.net/u012011360/article/details/41846905">chrome显示12px以下字体的解决方法</a></h2>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display: 'block'; font-size='16px'; transform: scale(0.5);"</span>&gt;</span>8px 字体<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<h2 id="%E8%B7%A8%E5%9F%9F">跨域</h2>
<ul>
<li>
<p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></p>
  <iframe src="https://segmentfault.com/a/1190000011145364" width="100%" frameborder="0" height="500px" ></iframe>
</li>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">CORS</a></p>
<pre class="hljs"><code><div>  Access-Control-Allow-Methods: GET, POST, PUT
  Access-Control-Allow-Headers: X-Custom-Header
  Access-Control-Allow-Credentials: <span class="hljs-literal">true</span>
  Access-Control-Max-Age: <span class="hljs-number">1728000</span>
</div></code></pre>
</li>
</ul>
<h2 id="%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%A7%BF%E5%8A%BF"><a href="https://zhuanlan.zhihu.com/p/29368435">跨页面通信的各种姿势</a></h2>
<h2 id="%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><a href="https://juejin.im/post/5c24d736f265da614b120d4a">深入浅出浏览器渲染原理</a></h2>
<h2 id="css-%E5%92%8C-js-%E8%A7%A3%E6%9E%90%E3%80%81%E6%B8%B2%E6%9F%93">CSS 和 JS 解析、渲染</h2>
<ul>
<li><a href="https://juejin.im/post/59c60691518825396f4f71a1">原来 CSS 与 JS 是这样阻塞 DOM 解析和渲染的</a></li>
<li><a href="https://juejin.im/post/5b88ddca6fb9a019c7717096">css加载会造成阻塞吗？</a>
<ul>
<li>DOM 解析和 CSSOM 解析是两个并行的线程，CSS 的加载不会阻塞 DOM 的解析</li>
<li>CSS 加载会阻塞 DOM 树的渲染的</li>
<li>由于 JS 会操作之前的 DOM 节点和 CSS 样式，因此，浏览器会维持 html 中 CSS 和 JS 的顺序。因此，CSS 会在后面的 JS 执行之前先加载执行完毕，所以 CSS 会阻塞后面 JS 的执行。</li>
</ul>
</li>
<li><a href="https://juejin.im/post/5b2a508ae51d4558de5bd5d1">再谈 load 与 DOMContentLoaded</a></li>
</ul>
<h2 id="event-loop">Event loop</h2>
<ul>
<li><a href="https://juejin.im/post/5b8f76675188255c7c653811">带你彻底弄懂Event Loop</a></li>
<li><a href="https://juejin.im/post/5afbc62151882542af04112d">浏览器事件循环机制（event loop）</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li>
</ul>
<h2 id="linux-io%E6%A8%A1%E5%BC%8F%E5%8F%8A-select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3"><a href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&amp;utm_medium=shareLink&amp;utm_campaign=socialShare#articleHeader0">Linux IO模式及 select、poll、epoll详解</a></h2>
<h2 id="v8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">V8引擎中的垃圾回收机制</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000000440270">浅谈V8引擎中的垃圾回收机制</a></li>
</ul>
<h2 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">浏览器缓存</h2>
<ul>
<li><a href="https://juejin.im/post/5c4528a6f265da611a4822cc">彻底搞懂浏览器缓存机制</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>
<ul>
<li>no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。</li>
<li>must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。</li>
</ul>
</li>
</ul>
<h2 id="dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%8F%8Adns%E4%BC%98%E5%8C%96"><a href="https://blog.csdn.net/cat_foursi/article/details/71194397">DNS解析过程及DNS优化</a></h2>
<h2 id="%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8">前端安全</h2>
<ul>
<li><a href="https://juejin.im/entry/598d6eb46fb9a03c3a25d2c1">前端安全知多少</a></li>
<li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">如何防止XSS攻击？</a>
<ul>
<li>
<p>xss</p>
<blockquote>
<p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p>
</blockquote>
<blockquote>
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>
</blockquote>
<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
- html 转义为实体
- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。</p>
</li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈CSRF攻击方式</a></li>
</ul>
<h2 id="%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><a href="https://csspod.com/frontend-performance-best-practices/">前端性能优化最佳实践</a></h2>
<h2 id="%E7%AE%97%E6%B3%95">算法</h2>
<ul>
<li><a href="https://juejin.im/post/5b72f0caf265da282809f3b5">前端笔试&amp;面试爬坑系列---算法</a></li>
</ul>
<h1 id="css">CSS</h1>
<h2 id="bfc">BFC</h2>
<ul>
<li>
<p><a href="https://segmentfault.com/a/1190000013647777">BFC(块格式化上下文)</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/5909db2fda2f60005d2093db">关于 CSS-BFC 深入理解</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/25321647">10 分钟理解 BFC 原理</a></p>
</li>
</ul>
<h2 id="%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8">清除浮动</h2>
<ul>
<li>
<p><a href="https://segmentfault.com/a/1190000008012247">清除浮动（clearfix）的常见方法</a></p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000013664630">clearfix（清除浮动）</a></p>
</li>
</ul>
<h2 id="%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87">层叠上下文</h2>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">深入理解 CSS 中的层叠上下文和层叠顺序</a></li>
</ul>
<p><img src="https://image.zhangxinxu.com/image/blog/201601/2016-01-09_211116.png" alt=""></p>
<h2 id="flex-%E5%B8%83%E5%B1%80">Flex 布局</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>
<ul>
<li>
<p>container 属性</p>
<ul>
<li>flex-direction:</li>
<li>flex-wrap: <code>nowrap</code>、<code>wrap</code>、<code>wrap-reverse</code>;</li>
<li>flex-flow: flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 <code>row nowrap</code>;</li>
<li>justify-content: flex-start | flex-end | center | space-between | space-around;</li>
<li>align-items: flex-start | flex-end | center | baseline | stretch;</li>
<li>align-content: 多根轴线的对齐方式。flex-start | flex-end | center | space-between | space-around | stretch</li>
</ul>
</li>
<li>
<p>子项的属性</p>
<ul>
<li>order</li>
<li>flex-grow: 定义项目的放大比例，默认为0</li>
<li>flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis: <code>&lt;length&gt; | auto</code>。 // 在分配多余空间之前，项目占据的主轴空间（main size）。默认值为auto，即项目的本来大小。</li>
<li>flex: flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</li>
<li>align-self: <code>auto | flex-start | flex-end | center | baseline | stretch</code>; 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程：实例篇</a></li>
</ul>
<h2 id="grid-%E5%B8%83%E5%B1%80">Grid 布局</h2>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/">写给自己看的display: grid布局教程</a></li>
</ul>
<h2 id="%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95"><a href="https://juejin.im/post/5b94d8965188255c5a0cdc02">居中方法</a></h2>
<h2 id="%E5%B0%8Ftips%E4%BA%86%E8%A7%A3csscss3%E5%8E%9F%E7%94%9F%E5%8F%98%E9%87%8Fvar"><a href="https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/">小tips:了解CSS/CSS3原生变量var</a></h2>
<h2 id="css%E5%AE%9E%E7%8E%B0%E9%95%BF%E5%AE%BD%E6%AF%94%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88"><a href="https://www.w3cplus.com/css/aspect-ratio.html">CSS实现长宽比的几种方案</a></h2>
<ul>
<li>
<p>CSS 实现自适应正方形</p>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid; width: 10vmin; height: 10vmin;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid; width: 30%; height: 0; padding-bottom: 30%;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> {
      <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;
      <span class="hljs-attribute">display</span>: block;
      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"border: 1px solid; width: 30%; overflow: hidden;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p><a href="https://www.jianshu.com/p/f13122a9651c">CSS3技巧之形状（椭圆）（border-raduis）</a></p>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 200px; height: 100px; border-raduis: 100px 50px; border: 1px solid;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
</li>
<li>
<p>三角形实现</p>
</li>
</ul>
<h2 id="%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0"><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/">伪类与伪元素</a></h2>
<h2 id="a-hrefindexhtml-targetblankcss-%E5%B8%83%E5%B1%80a"><a href="./index.html" target="_blank">css 布局</a></h2>
<ul>
<li><a href="https://juejin.im/post/5a260aaa6fb9a0451b0464f0">css 网页的几种布局</a></li>
<li><a href="https://mp.weixin.qq.com/s/iQ8mSr4oEAC8Ve6IdiN9jQ">CSS 布局说——可能是最全的</a></li>
</ul>
<h1 id="%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</h1>
<h2 id="http">http</h2>
<ul>
<li>
<p><a href="https://www.cnblogs.com/klguang/p/4618526.html">HTTP 报文</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/24913080">HTTP 协议</a></p>
</li>
<li>
<p><a href="https://itbilu.com/other/relate/EkwKysXIl.html">HTTP 请求方法：GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4">HTTP 中 GET 与 POST 的区别</a></p>
<p><strong>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p>
<ol>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
<li><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong><br>
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ol>
</li>
<li>
<p>HTTP 请求优化</p>
<ul>
<li><a href="https://juejin.im/post/59f44c5ef265da4327177b98">前端性能优化之http请求的过程</a></li>
</ul>
</li>
</ul>
<h2 id="https">https</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/27395037">HTTPS 原理详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24854237">HTTPS</a></li>
</ul>
<h2 id="http2">HTTP/2</h2>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html">HTTP/2 幕后原理</a></li>
<li><a href="https://juejin.im/post/5b88a4f56fb9a01a0b31a67e">HTTP2 详解</a>
<ol>
<li>二进制分帧层</li>
<li>多路复用</li>
<li>服务端推送</li>
<li>Header 压缩（使用 HPACK 算法来压缩首部内容）</li>
<li>流量控制</li>
</ol>
</li>
</ul>
<h2 id="tcp">TCP</h2>
<ul>
<li>
<p><a href="https://yonghaowu.github.io/2019/01/11/http_rfc_handshake/">三次握手的误解与错误类比(RFC解读)</a></p>
<p>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。</p>
</li>
<li>
<p><a href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 三次握手</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/35768805">TCP 三次握手、四次挥手</a></p>
</li>
<li>
<p><a href="https://github.com/jawil/blog/issues/14">通俗大白话来理解TCP协议的三次握手和四次分手</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/zhangdaisylove/article/details/47294315">TCP的滑动窗口与拥塞窗口</a></p>
</li>
<li>
<p><a href="https://my.oschina.net/xinxingegeya/blog/485650">TCP 滑动窗口（发送窗口和接收窗口）</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/yao5hed/article/details/81046945">解析TCP之滑动窗口(动画演示)</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口（Sliding Window）</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/jtracydy/article/details/52366461">TCP拥塞控制-慢启动、拥塞避免、快重传、快启动</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/wdscq1234/article/details/52517420">TCP-IP 详解: 慢启动和拥塞控制</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/rock_joker/article/details/76769404">TCP 协议详解(慢启动,流量控制,阻塞控制之类)</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/47064829">TCP 协议与 UDP 协议的区别</a></p>
</li>
</ul>
<h1 id="reactredux">React/redux</h1>
<h2 id="%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">受控组件和非受控组件</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000012404114">React中受控与非受控组件</a></li>
<li><a href="https://www.jianshu.com/p/fb915d9c99c4">React 中组件间通信的几种方式</a></li>
</ul>
<h2 id="vdom-react-%E5%8E%9F%E7%90%86">vDom react 原理</h2>
<h2 id="diff-%E7%9A%84%E5%8E%9F%E7%90%86">diff 的原理</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/20346379">react diff</a></li>
</ul>
<h2 id="setstate"><strong>setState</strong></h2>
<ul>
<li>react@16.x
<ul>
<li>Calling setState with null no longer triggers an update. This allows you to decide in an updater function if you want to re-render.</li>
<li>Calling setState directly in render always causes an update. This was not previously the case. Regardless, you should not be calling setState from render.</li>
<li>setState callback (second argument) now fires immediately after <code>componentDidMount / componentDidUpdate</code> instead of after all components have <code>rendered</code>.</li>
</ul>
</li>
<li><a href="https://imweb.io/topic/5b189d04d4c96b9b1b4c4ed6">setState</a></li>
</ul>
<h2 id="%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%88syntheticevent%EF%BC%89"><a href="https://reactjs.org/docs/events.html">合成事件（SyntheticEvent）</a></h2>
<ul>
<li>
<p>SyntheticEvent object</p>
<pre class="hljs"><code><div>  boolean bubbles
  boolean cancelable
  DOMEventTarget currentTarget
  boolean defaultPrevented
  number eventPhase
  boolean isTrusted
  DOMEvent nativeEvent
  <span class="hljs-keyword">void</span> preventDefault()
  boolean isDefaultPrevented()
  <span class="hljs-keyword">void</span> stopPropagation()
  boolean isPropagationStopped()
  DOMEventTarget target
  number timeStamp
  string type
</div></code></pre>
</li>
<li>
<p>Event Pooling</p>
<p>SyntheticEvent 对象会被重用，并且在调用事件回调后，所有属性都将无效。<strong>切勿异步调用访问 SyntheticEvent 对象</strong></p>
<blockquote>
<p>如果要以异步方式访问事件属性，则应在事件上调用 event.persist()，这将从池中删除合成事件，并允许用户代码保留对事件的引用。</p>
</blockquote>
</li>
<li>
<p>捕获阶段添加事件</p>
<p>事件处理程序由冒泡阶段的事件触发。要为捕获阶段注册事件处理程序，请将Capture附加到事件名称；例如，您可以使用 onClickCapture 来处理捕获阶段中的 click 事件，而不是使用 onClick。</p>
</li>
<li>
<p><a href="https://juejin.im/post/59db6e7af265da431f4a02ef">React合成事件和DOM原生事件混用须知</a></p>
</li>
</ul>
<h2 id="react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">React 性能优化</h2>
<h2 id="react-router%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">react-router内部实现机制</h2>
<ul>
<li><a href="https://github.com/youngwind/blog/issues/109">单页面应用路由实现原理：以 React-Router 为例</a></li>
</ul>
<h2 id="react-redux">react-redux</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Provider</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props)

    <span class="hljs-comment">// 获取store</span>
    <span class="hljs-keyword">const</span> { store } = props

    <span class="hljs-comment">// 初始化state, storeState为初始的redux state</span>
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">storeState</span>: store.getState(),
      <span class="hljs-comment">// 保存init store</span>
      store
    }
  }

  componentDidMount() {
    <span class="hljs-comment">// 文件收索_isMounted， 共三处， componentWillUnmount中赋值为false</span>
    <span class="hljs-comment">// 先假设为标记componentDidMount -&gt; componentWillUnmount中</span>
    <span class="hljs-keyword">this</span>._isMounted = <span class="hljs-literal">true</span>
    <span class="hljs-comment">// 来看下subscribe</span>
    <span class="hljs-keyword">this</span>.subscribe()
  }

  <span class="hljs-comment">// 使用store.subscribe方法，保证storeState的最新</span>
  subscribe() {
    <span class="hljs-keyword">const</span> { store } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-comment">// 监听subscribe</span>
    <span class="hljs-keyword">this</span>.unsubscribe = store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
     <span class="hljs-comment">// 获取最新的state赋值给newStoreState</span>
      <span class="hljs-keyword">const</span> newStoreState = store.getState()
      <span class="hljs-comment">// 不在本次生命周期中return</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._isMounted) {
        <span class="hljs-keyword">return</span>
      }

      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">providerState</span> =&gt;</span> {
        <span class="hljs-comment">// If the value is the same, skip the unnecessary state update.</span>
        <span class="hljs-comment">// 如果state是相同的引用， 直接跳过state的更新</span>
        <span class="hljs-keyword">if</span> (providerState.storeState === newStoreState) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }

        <span class="hljs-comment">// 更新当前storeState</span>
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">storeState</span>: newStoreState }
      })
    })
    
    <span class="hljs-keyword">const</span> postMountStoreState = store.getState()
    <span class="hljs-keyword">if</span> (postMountStoreState !== <span class="hljs-keyword">this</span>.state.storeState) {
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">storeState</span>: postMountStoreState })
    }
  }

  render() {
    <span class="hljs-comment">// ReactReduxContext为默认context, 点过去看一下默认值。 看 -&gt; context.js文件，createContext参数是null</span>
    <span class="hljs-keyword">const</span> Context = <span class="hljs-keyword">this</span>.props.context || ReactReduxContext

    <span class="hljs-comment">// value 为this.state</span>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state}</span>&gt;</span>
        {this.props.children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span>
    )
  }

</span></div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// connectAdvanced高阶函数</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connectAdvanced</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapWithConnect</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OuterBaseComponent</span> </span>{

      renderWrappedComponent(value) {
        <span class="hljs-comment">// 获取redux state和store</span>
        <span class="hljs-keyword">const</span> { storeState, store } = value

        <span class="hljs-comment">// 定义wrapperProps为this.props</span>
        <span class="hljs-keyword">let</span> wrapperProps = <span class="hljs-keyword">this</span>.props

        <span class="hljs-comment">// 导出props</span>
        <span class="hljs-keyword">let</span> derivedProps = <span class="hljs-keyword">this</span>.selectDerivedProps(
          storeState,
          wrapperProps,
          store
        )

        <span class="hljs-comment">// 返回最终的组件,传入最终的props和ref -&gt; 看selectChildElement发放</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selectChildElement(derivedProps, forwardedRef)
      }

      render() {
        <span class="hljs-comment">// 默认情况下公用的ReactReduxContext</span>
        <span class="hljs-keyword">const</span> ContextToUse = <span class="hljs-keyword">this</span>.props.context || Context

        <span class="hljs-keyword">return</span> (
          <span class="hljs-comment">// &lt;Privoder /&gt;的消费者</span>
          &lt;ContextToUse.Consumer&gt;
            {<span class="hljs-keyword">this</span>.renderWrappedComponent}
          &lt;<span class="hljs-regexp">/ContextToUse.Consumer&gt;
        )
      }
    }
    return hoistStatics(Connect, WrappedComponent)
  }
}
</span></div></code></pre>
<h2 id="redux-%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">redux 基本组成和设计单向数据流</h2>
<ul>
<li>
<p><a href="https://juejin.im/post/5ae7db125188253dc6127bc7">redux 源码解读</a></p>
</li>
<li>
<p><a href="https://zcfy.cc/article/master-the-javascript-interview-what-is-a-pure-function-2186.html">征服 JavaScript 面试：什么是纯函数？</a></p>
<ul>
<li>相同的输入，相同的输出</li>
<li>没有副作用</li>
<li>不会依赖外部状态</li>
</ul>
</li>
</ul>
<h1 id="angular">Angular</h1>
<ul>
<li><a href="https://www.cnblogs.com/likeFlyingFish/p/6183630.html">AngularJS 脏检查深入分析</a></li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-comment">/**
 * 藏检查的内部实现
 *
 * 每当我们将数据绑定到 UI 上，angular 就会向你的 watchList 上插入一个 $watch。
 * 只有当触发UI事件，ajax请求或者 timeout 延迟，才会触发脏检查。
 *
 * getter 和 setter 是Vue 采用的机制,我觉得他两个最大的区别就是 Angular 采用事件驱动,而Vue 采用数据驱动 .所以 Angular 是当界面事件 或者其他 来触发脏检查, 而Vue 是检测后台数据变化,一旦变化 被 setter 捕捉, 然后来触发 界面更新. 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$Scope</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.$$watchList = [];
}

$Scope.prototype.$watch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, getNewValue, listener</span>) </span>{
 <span class="hljs-keyword">const</span> watch = {
   <span class="hljs-attr">name</span>: name,
   <span class="hljs-attr">getNewValue</span>: getNewValue,
   <span class="hljs-attr">listener</span>: listener || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},
 };

 <span class="hljs-keyword">this</span>.$$watchList.push(watch);
}

$Scope.prototype.$digest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> dirty = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">let</span> checkTimes = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(dirty) {
    dirty = <span class="hljs-keyword">this</span>.$digestOnce();
    checkTimes++;
    <span class="hljs-keyword">if</span>(checkTimes &gt; <span class="hljs-number">10</span> &amp;&amp; dirty) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'检测次数超过10次'</span>);
    }
  }
}

$Scope.prototype.$digestOnce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> dirty=<span class="hljs-literal">false</span>;
  <span class="hljs-keyword">const</span> list = <span class="hljs-keyword">this</span>.$$watchList;

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>, len = list.length; i&lt;len; i++ ) {
    <span class="hljs-keyword">const</span> watch = list[i];
    <span class="hljs-keyword">const</span> newValue = watch.getNewValue(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 传入 scope 获取 scope 内值</span>
    <span class="hljs-keyword">const</span> oldValue = watch.last;

    <span class="hljs-keyword">if</span>(newValue !== oldValue) {
      watch.listen(newValue, oldValue);
      dirty = <span class="hljs-literal">true</span>;
    }

    watch.last = newValue;
  }

  <span class="hljs-keyword">return</span> dirty;
}

<span class="hljs-comment">/***************************************************/</span>

<span class="hljs-keyword">const</span> scope = <span class="hljs-keyword">new</span> $Scope();
scope.first = <span class="hljs-number">1</span>;
scope.secode = <span class="hljs-number">10</span>;

scope.$watch(<span class="hljs-string">'first'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_scope</span>)</span>{
  <span class="hljs-keyword">return</span> _scope[<span class="hljs-keyword">this</span>.name]; <span class="hljs-comment">//  getNewValue 通过 watch.getNewValue 方式调用，this 指向 watch</span>
}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue, oldValue</span>) </span>{
  scope.second++;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'first:      newValue:'</span> + newValue + <span class="hljs-string">'-----'</span> + <span class="hljs-string">'oldValue:'</span> + oldValue);
})

scope.$watch(<span class="hljs-string">'second'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_scope</span>)</span>{
  <span class="hljs-keyword">return</span> _scope[<span class="hljs-keyword">this</span>.name];
}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue, oldValue</span>)</span>{
  scope.first++;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'second:     newValue:'</span> + newValue + <span class="hljs-string">'-----'</span> + <span class="hljs-string">'oldValue:'</span> + oldValue)
})

scope.$digest();
</div></code></pre>
<ul>
<li><a href="https://www.zhihu.com/question/36040694/answer/65624196">如何衡量一个人的 AngularJS 水平？</a></li>
<li><a href="https://www.cnblogs.com/likeFlyingFish/p/6201106.html">基于 getter 和 setter 撸一个简易的MVVM</a></li>
</ul>
<h1 id="nodejs">NodeJS</h1>
<h2 id="nodejs-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6"><a href="https://juejin.im/entry/5b4b5081e51d451984696cb7">Node.js 中的模块机制</a></h2>
<h2 id="nodejs-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop">NodeJS 的事件循环(Event Loop)</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/33058983">详解 JavaScript 中的 Event Loop（事件循环）机制</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34451546">Node.js 的事件循环(Event Loop)、Timer 和 process.nextTick()[翻译]</a></li>
</ul>
<h2 id="stream">Stream</h2>
<ul>
<li><a href="https://juejin.im/post/5940a9c3128fe1006a0ab176">Node.js Stream: 你需要知道的一切</a></li>
<li><a href="https://juejin.im/post/5a6c7c4df265da3e5234bf14">模拟实现和深入理解Node Stream内部机制</a></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/14/d4fff9e6bbb5bb32864b1c64b3169876?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/6/14/03e1f627b419676dbb727ab9bc35e77e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><a href="https://blog.csdn.net/u012134199/article/details/46290465">单线程与多线程的区别</a></h2>
<h2 id="nodejs-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AE%A8%E8%AE%BA"><a href="https://www.cnblogs.com/sysuys/p/3460614.html">[NodeJS] 优缺点及适用场景讨论</a></h2>
<h2 id="koa-%E7%9A%84%E5%8E%9F%E7%90%86%E7%BB%A7%E6%89%BF">koa 的原理,继承</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// application.js</span>

<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Emitter</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.proxy = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.middleware = []
    <span class="hljs-keyword">this</span>.env = process.env.NODE_ENV || <span class="hljs-string">'development'</span>
    <span class="hljs-keyword">this</span>.context = <span class="hljs-built_in">Object</span>.create(context)
    <span class="hljs-keyword">this</span>.request = <span class="hljs-built_in">Object</span>.create(request)
    <span class="hljs-keyword">this</span>.response = <span class="hljs-built_in">Object</span>.create(response)
  }

  listen(...args) {
    <span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-keyword">this</span>.callback())
    server.listen(...args)
  }

  use(fn) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">''</span>)
    <span class="hljs-keyword">if</span> (isGeneratorFunction(fn)) {
      <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">''</span>)
      fn = convert(fn)
    }
    <span class="hljs-keyword">this</span>.middleware.push(fn)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }

  callback() {
    <span class="hljs-comment">// 生成 handle fn</span>
    fn = compose(<span class="hljs-keyword">this</span>.middleware)

    <span class="hljs-comment">// 添加默认的 error handle</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.listenCounter(<span class="hljs-string">'error'</span>)) <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">this</span>.onerror)

    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
      <span class="hljs-comment">// 生成 ctx</span>
      <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>.createContext(req, res)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handleRequest(ctx, fn)
    }
  }

  handleRequest(ctx, fnMiddleware) {
    <span class="hljs-keyword">const</span> res = ctx.res
    res.statusCode = <span class="hljs-number">404</span>
    <span class="hljs-keyword">const</span> onerror = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> ctx.onerror(err)
    <span class="hljs-keyword">const</span> handleResponse = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> respond(ctx)
    onFinished(res, onerror)
    fnMiddleware(ctx)
      .then(handleResponse)
      .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> onerror)
  }

  createContext(req, res) {
    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.context)
    <span class="hljs-keyword">const</span> request = (context.request = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.request))
    <span class="hljs-keyword">const</span> response = (context.response = <span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.response))
    context.app = request.app = response.app = <span class="hljs-keyword">this</span>
    context.req = request.req = response.req = req
    context.res = request.res = response.res = res
    request.ctx = response.ctx = context
    request.response = response
    response.request = request
    context.originalUrl = request.originalUrl = req.url
    context.state = {}
    <span class="hljs-keyword">return</span> context
  }

  onerror(err) {
    <span class="hljs-keyword">if</span> (!(err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(util.format(<span class="hljs-string">'non-error thrown: %j'</span>, err))

    <span class="hljs-keyword">if</span> (<span class="hljs-number">404</span> == err.status || err.expose) <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.silent) <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">const</span> msg = err.stack || err.toString()
    <span class="hljs-built_in">console</span>.error()
    <span class="hljs-built_in">console</span>.error(msg.replace(<span class="hljs-regexp">/^/gm</span>, <span class="hljs-string">'  '</span>))
    <span class="hljs-built_in">console</span>.error()
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">respond</span>(<span class="hljs-params">ctx</span>) </span>{
  <span class="hljs-comment">// allow bypassing koa</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span> === ctx.respond) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">const</span> res = ctx.res
  <span class="hljs-keyword">if</span> (!ctx.writable) <span class="hljs-keyword">return</span>

  <span class="hljs-keyword">let</span> body = ctx.body
  <span class="hljs-keyword">const</span> code = ctx.status

  <span class="hljs-comment">// ignore body</span>
  <span class="hljs-keyword">if</span> (statuses.empty[code]) {
    <span class="hljs-comment">// strip headers</span>
    ctx.body = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">return</span> res.end()
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-string">'HEAD'</span> == ctx.method) {
    <span class="hljs-keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) {
      ctx.length = Buffer.byteLength(<span class="hljs-built_in">JSON</span>.stringify(body))
    }
    <span class="hljs-keyword">return</span> res.end()
  }

  <span class="hljs-comment">// status body</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == body) {
    <span class="hljs-keyword">if</span> (ctx.req.httpVersionMajor &gt;= <span class="hljs-number">2</span>) {
      body = <span class="hljs-built_in">String</span>(code)
    } <span class="hljs-keyword">else</span> {
      body = ctx.message || <span class="hljs-built_in">String</span>(code)
    }
    <span class="hljs-keyword">if</span> (!res.headersSent) {
      ctx.type = <span class="hljs-string">'text'</span>
      ctx.length = Buffer.byteLength(body)
    }
    <span class="hljs-keyword">return</span> res.end(body)
  }

  <span class="hljs-comment">// responses</span>
  <span class="hljs-keyword">if</span> (Buffer.isBuffer(body)) <span class="hljs-keyword">return</span> res.end(body)
  <span class="hljs-keyword">if</span> (<span class="hljs-string">'string'</span> == <span class="hljs-keyword">typeof</span> body) <span class="hljs-keyword">return</span> res.end(body)
  <span class="hljs-keyword">if</span> (body <span class="hljs-keyword">instanceof</span> Stream) <span class="hljs-keyword">return</span> body.pipe(res)

  <span class="hljs-comment">// body: json</span>
  body = <span class="hljs-built_in">JSON</span>.stringify(body)
  <span class="hljs-keyword">if</span> (!res.headersSent) {
    ctx.length = Buffer.byteLength(body)
  }
  res.end(body)
}
</div></code></pre>
<h1 id="%E7%AE%97%E6%B3%95">算法</h1>
<h2 id="others">others</h2>
<ul>
<li>有没有使用过 css3 动画，介绍一下,怎么做，关键是怎么做的 CSS</li>
<li>单行文本溢出，多行文本溢出把代码实现写出来</li>
<li>闭包，平时在哪用到？ 立即执行函数解决闭包中访问变量的问题</li>
<li>算法 快拍 选择排序</li>
<li>内存溢出</li>
<li>页面渲染 1000 个元素</li>
<li>页面性能优化</li>
</ul>

</body>
</html>
